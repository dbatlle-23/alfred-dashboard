from dash import html, dcc, callback_context
import dash
import dash_bootstrap_components as dbc
from dash.dependencies import Input, Output, State, ALL
from components.smart_locks.lock_list import create_locks_list
from components.smart_locks.lock_table import create_locks_table
from components.smart_locks.nfc_grid import create_nfc_display_grid, create_lock_type_grid
from utils.logging import get_logger
from utils.error_handlers import handle_exceptions
from utils.api import get_devices, get_nfc_passwords, update_nfc_code_value, get_project_assets, get_asset_devices
import time
import concurrent.futures
from concurrent.futures import ThreadPoolExecutor
import re

logger = get_logger(__name__)

# Layout para la página de Smart Locks
layout = html.Div([
    # Stores para datos
    dcc.Store(id="smart-locks-data-store"),
    dcc.Store(id="smart-locks-refresh-trigger"),
    dcc.Store(id="smart-locks-view-preference", data={"view": "table"}),  # Default a vista de tabla
    dcc.Store(id="nfc-update-trigger", data={"updated": False}),  # Trigger para actualizar valores NFC
    dcc.Store(id="current-device-store", data=None),  # Almacena información del dispositivo actual
    
    # Contenedor principal
    dbc.Container([
        # Título y descripción
        html.H2("Gestión de Cerraduras Inteligentes", className="mb-3"),
        html.P("Administre y controle las cerraduras inteligentes de sus proyectos", className="lead mb-4"),
        
        # Filtros
        dbc.Card([
            dbc.CardBody([
                dbc.Row([
                    # Filtro de cliente
                    dbc.Col([
                        html.Label("Cliente"),
                        dcc.Dropdown(
                            id="smart-locks-client-filter",
                            placeholder="Seleccione un cliente",
                            clearable=False
                        )
                    ], width=4),
                    
                    # Filtro de proyecto
                    dbc.Col([
                        html.Label("Proyecto"),
                        dcc.Dropdown(
                            id="smart-locks-project-filter",
                            placeholder="Seleccione un proyecto",
                            clearable=False,
                            disabled=True
                        )
                    ], width=4),
                    
                    # Botones de acción
                    dbc.Col([
                        html.Div([
                            dbc.Button(
                                "Mostrar Cerraduras",
                                id="smart-locks-show-button",
                                color="primary",
                                className="me-2 mt-4",
                                disabled=True
                            ),
                            dbc.Button(
                                html.I(className="fas fa-sync"), 
                                id="smart-locks-refresh-button",
                                color="light",
                                className="mt-4",
                                disabled=True,
                                title="Actualizar datos"
                            )
                        ], className="d-flex justify-content-end")
                    ], width=4)
                ]),
                
                # Filtro de tipo de cerradura (aparece después de cargar datos)
                html.Div([
                    dbc.Row([
                        dbc.Col([
                            html.Label("Tipo de cerradura"),
                            dcc.Dropdown(
                                id="smart-locks-type-filter",
                                placeholder="Seleccione un tipo de cerradura",
                                clearable=False,
                                options=[]
                            )
                        ], width=8),
                        dbc.Col([
                            html.Div(id="smart-locks-type-filter-info", className="mt-4 pt-1")
                        ], width=4)
                    ])
                ], id="smart-locks-type-filter-container", style={"display": "none"}, className="mt-3")
            ])
        ], className="mb-4"),
        
        # Indicador de carga
        dbc.Spinner(html.Div(id="smart-locks-loading-indicator"), color="primary", type="grow"),
        
        # Pestañas para diferentes vistas
        dbc.Tabs([
            # Pestaña para vista de cerraduras
            dbc.Tab([
                # Toggle para cambiar entre vistas de tabla y grid
                html.Div([
                    html.Div([
                        dbc.ButtonGroup([
                            dbc.Button(
                                [html.I(className="fas fa-table me-1"), " Tabla"],
                                id="smart-locks-table-view-button",
                                color="primary",
                                outline=True,
                                className="view-toggle-button"
                            ),
                            dbc.Button(
                                [html.I(className="fas fa-th-large me-1"), " Grid"],
                                id="smart-locks-grid-view-button",
                                color="primary",
                                outline=True,
                                className="view-toggle-button"
                            )
                        ], className="view-toggle-container")
                    ], className="d-flex justify-content-end mb-3", style={"visibility": "hidden"}, id="smart-locks-view-toggle-container")
                ]),
                
                # Contenedor para la lista de cerraduras
                html.Div(id="smart-locks-list-container", className="mt-2"),
            ], label="Cerraduras", tab_id="locks-tab"),
            
            # Pestaña para vista de matriz NFC
            dbc.Tab([
                # Contenedor para la matriz NFC
                html.Div(id="nfc-grid-container", className="mt-4")
            ], label="Matriz de Códigos NFC", tab_id="nfc-grid-tab"),
            
            # NUEVA PESTAÑA: Debug de NFC
            dbc.Tab([
                # Contenedor para la vista de depuración
                html.Div([
                    # Título y descripción
                    html.H4("Depuración de Códigos NFC", className="mb-3"),
                    html.P([
                        html.I(className="fas fa-info-circle me-2"),
                        "Esta vista muestra información detallada de todas las cerraduras y sus sensores NFC para facilitar la depuración."
                    ], className="alert alert-info"),
                    
                    # Spinner para mostrar carga de datos
                    dbc.Spinner(id="debug-loading-indicator", color="primary", type="grow", className="mb-3"),
                    
                    # Store para guardar datos de debug
                    dcc.Store(id="debug-data-store", data={}),
                    
                    # SECCIÓN 1: Tabla principal con cerraduras y sus sensores NFC
                    html.Div([
                        html.H5("Tabla de Cerraduras y Sensores NFC", className="mb-3"),
                        
                        # Tabla de cerraduras y sensores
                        html.Div(id="debug-table-container", className="mt-3")
                    ], className="mb-4"),
                    
                    # SECCIÓN 2: Consultas de API
                    html.Div([
                        html.H5("Consultas de API por Asset", className="mb-3"),
                        
                        # Selector de Asset
                        dbc.Row([
                            dbc.Col([
                                html.Label("Seleccione un Asset para depurar:"),
                                dcc.Dropdown(
                                    id="debug-asset-selector",
                                    placeholder="Seleccione un Asset...",
                                    className="mb-3"
                                )
                            ], width=6)
                        ]),
                        
                        # Botón para consultar datos del Asset seleccionado
                        dbc.Button([
                            html.I(className="fas fa-search me-2"),
                            "Consultar datos del Asset"
                        ], id="debug-query-asset-button", color="primary", className="mb-3"),
                        
                        # Área para mostrar resultados
                        html.Div(id="debug-api-results", className="mt-3 p-3 border rounded bg-light")
                    ], className="mb-4"),
                    
                    # SECCIÓN 3: Comparador de datos
                    html.Div([
                        html.H5("Comparador de Datos", className="mb-3"),
                        
                        # Selector de Dispositivo
                        dbc.Row([
                            dbc.Col([
                                html.Label("Seleccione un Dispositivo para comparar:"),
                                dcc.Dropdown(
                                    id="debug-device-selector",
                                    placeholder="Seleccione un Dispositivo...",
                                    className="mb-3"
                                )
                            ], width=6)
                        ]),
                        
                        # Botón para comparar datos 
                        dbc.Button([
                            html.I(className="fas fa-code-compare me-2"),
                            "Comparar datos del dispositivo"
                        ], id="debug-compare-device-button", color="primary", className="mb-3"),
                        
                        # Área para mostrar comparación
                        html.Div(id="debug-comparison-results", className="mt-3 p-3 border rounded bg-light")
                    ])
                ], id="debug-container", className="mt-4")
            ], label="Debug", tab_id="debug-tab"),
        ], id="smart-locks-tabs", active_tab="locks-tab"),
        
        # Modal para detalles y acciones adicionales
        dbc.Modal([
            dbc.ModalHeader(dbc.ModalTitle("Detalles de Cerradura"), close_button=True),
            dbc.ModalBody([
                # Contenedor de información de la cerradura
                html.Div(id="smart-locks-modal-content", className="lock-details-container"),
                
                # Spinner para estados de carga
                dbc.Spinner(id="smart-locks-modal-loading", color="primary", type="grow", size="sm"),
                
                # Alerta para mensajes de feedback
                html.Div(id="smart-locks-modal-feedback")
            ]),
            dbc.ModalFooter([
                dbc.Button("Cerrar", id="smart-locks-modal-close", className="ms-auto", n_clicks=0)
            ])
        ], id="smart-locks-modal", size="lg", is_open=False, centered=True, backdrop="static"),
        
        # Modal para confirmación de acciones
        dbc.Modal([
            dbc.ModalHeader(dbc.ModalTitle("Confirmar Acción")),
            dbc.ModalBody(id="smart-locks-confirm-modal-body"),
            dbc.ModalFooter([
                dbc.Button("Cancelar", id="smart-locks-confirm-cancel", className="me-2", n_clicks=0),
                dbc.Button("Confirmar", id="smart-locks-confirm-action", color="danger", n_clicks=0)
            ])
        ], id="smart-locks-confirm-modal", size="md", is_open=False),
        
        # Modal para edición de códigos NFC
        dbc.Modal([
            dbc.ModalHeader(dbc.ModalTitle("Editar Código NFC"), close_button=True),
            dbc.ModalBody([
                # Información del sensor NFC
                html.Div(id="nfc-edit-info", className="mb-3"),
                
                # Campo de edición (actualizado para eliminar FormGroup)
                dbc.Row([
                    dbc.Col([
                        dbc.Label("Nuevo valor:", className="fw-bold"),
                        dbc.Input(
                            id="nfc-edit-value-input",
                            type="text",
                            placeholder="Introduce el nuevo código NFC",
                            maxLength=50
                        ),
                        dbc.FormText("El código debe seguir el formato requerido por el dispositivo.", color="muted")
                    ])
                ]),
                
                # Mensajes de error o éxito
                html.Div(id="nfc-edit-feedback", className="mt-3")
            ]),
            dbc.ModalFooter([
                dbc.Button("Cancelar", id="nfc-edit-cancel", className="me-2", n_clicks=0),
                dbc.Button("Guardar", id="nfc-edit-save", color="primary", n_clicks=0)
            ])
        ], id="nfc-edit-modal", size="md", is_open=False),
        
        # Interval para cerrar el modal de edición después de guardar
        dcc.Interval(id="nfc-edit-success-timer", interval=2000, n_intervals=0, max_intervals=1, disabled=True)
    ])
])

# Registrar callbacks para la página de Smart Locks
def register_callbacks(app):
    """
    Registra los callbacks para la página de Smart Locks
    
    Args:
        app: Instancia de la aplicación Dash
    """
    # Callback para cambiar la vista (tabla o grid)
    @app.callback(
        [Output("smart-locks-view-preference", "data"),
         Output("smart-locks-table-view-button", "outline"),
         Output("smart-locks-grid-view-button", "outline")],
        [Input("smart-locks-table-view-button", "n_clicks"),
         Input("smart-locks-grid-view-button", "n_clicks")],
        [State("smart-locks-view-preference", "data")]
    )
    def toggle_view(table_clicks, grid_clicks, current_view):
        ctx = dash.callback_context
        if not ctx.triggered:
            # Valores por defecto
            return current_view, not current_view.get("view") == "table", not current_view.get("view") == "grid"
        
        # Determinar qué botón se ha pulsado
        button_id = ctx.triggered[0]["prop_id"].split(".")[0]
        
        if button_id == "smart-locks-table-view-button":
            return {"view": "table"}, False, True
        elif button_id == "smart-locks-grid-view-button":
            return {"view": "grid"}, True, False
        
        # En caso de no reconocer el botón, mantener vista actual
        return current_view, not current_view.get("view") == "table", not current_view.get("view") == "grid"
    
    # Callback para mostrar/ocultar el toggle de vista según haya datos o no
    @app.callback(
        Output("smart-locks-view-toggle-container", "style"),
        [Input("smart-locks-data-store", "data")]
    )
    def toggle_view_container_visibility(data):
        if data:
            return {"visibility": "visible"}
        return {"visibility": "hidden"}
    
    # Callback para mostrar la lista de cerraduras según la vista seleccionada
    @app.callback(
        Output("smart-locks-list-container", "children"),
        [Input("smart-locks-data-store", "data"),
         Input("smart-locks-view-preference", "data")]
    )
    @handle_exceptions(default_return=html.Div("Error al cargar cerraduras", className="alert alert-danger"))
    def update_locks_list(devices_data, view_preference):
        if not devices_data:
            return html.Div([
                html.I(className="fas fa-info-circle me-2"),
                "Seleccione un proyecto y haga clic en 'Mostrar Cerraduras' para ver las cerraduras disponibles"
            ], className="alert alert-info")
        
        view = view_preference.get("view", "table")
        if view == "grid":
            return create_locks_list(devices_data)
        else:
            return create_locks_table(devices_data)
    
    # Callback para cargar la lista de clientes
    @app.callback(
        Output("smart-locks-client-filter", "options"),
        [Input("jwt-token-store", "data")],
        prevent_initial_call=False
    )
    @handle_exceptions(default_return=[{"label": "Error al cargar", "value": "all"}])
    def load_clients(token_data):
        from utils.api import get_clientes
        
        # Obtener el token JWT del store
        token = token_data.get('token') if token_data else None
        
        # Si no hay token, mostrar opciones por defecto
        if not token:
            logger.info("No hay token JWT disponible para cargar clientes")
            return [{"label": "Seleccione un cliente", "value": ""}]
        
        # Obtener la lista de clientes
        clientes = get_clientes(jwt_token=token)
        
        # Opciones para el dropdown de clientes
        client_options = []
        
        # Extender con los clientes de la API
        for cliente in clientes:
            if not isinstance(cliente, dict):
                continue
                
            # Intentar obtener el nombre y el ID con diferentes claves posibles
            nombre = None
            id_cliente = None
            
            # Posibles claves para el nombre
            for key in ['nombre', 'name', 'client_name', 'nombre_cliente', 'client']:
                if key in cliente:
                    nombre = cliente[key]
                    break
            
            # Posibles claves para el ID
            for key in ['id', 'client_id', 'id_cliente', 'clientId']:
                if key in cliente:
                    id_cliente = cliente[key]
                    break
            
            # Si tenemos tanto nombre como ID, añadir a las opciones
            if nombre and id_cliente is not None:
                client_options.append({"label": nombre, "value": str(id_cliente)})
        
        return client_options
    
    # Callback para cargar la lista de proyectos cuando cambia el cliente seleccionado
    @app.callback(
        [Output("smart-locks-project-filter", "options"),
         Output("smart-locks-project-filter", "disabled")],
        [Input("smart-locks-client-filter", "value"),
         Input("jwt-token-store", "data")],
        prevent_initial_call=False
    )
    @handle_exceptions(default_return=[[{"label": "Error al cargar", "value": ""}], True])
    def load_projects(client_id, token_data):
        from utils.api import get_projects
        
        # Obtener el token JWT del store
        token = token_data.get('token') if token_data else None
        
        # Si no hay token o cliente seleccionado, mantener deshabilitado
        if not token or not client_id:
            return [{"label": "Seleccione primero un cliente", "value": ""}], True
        
        # Obtener la lista de proyectos para el cliente seleccionado
        projects = get_projects(client_id=client_id, jwt_token=token)
        
        # Opciones para el dropdown de proyectos
        project_options = []
        
        # Extender con los proyectos de la API
        for project in projects:
            if not isinstance(project, dict):
                continue
            
            # Intentar obtener el nombre y el ID con diferentes claves posibles
            nombre = None
            id_proyecto = None
            
            # Posibles claves para el nombre
            for key in ['nombre', 'name', 'project_name', 'nombre_proyecto']:
                if key in project:
                    nombre = project[key]
                    break
            
            # Posibles claves para el ID
            for key in ['id', 'project_id', 'id_proyecto', 'projectId']:
                if key in project:
                    id_proyecto = project[key]
                    break
            
            # Si tenemos tanto nombre como ID, añadir a las opciones
            if nombre and id_proyecto is not None:
                project_options.append({"label": nombre, "value": str(id_proyecto)})
        
        return project_options, False
    
    # Callback para habilitar/deshabilitar el botón de mostrar cerraduras
    @app.callback(
        Output("smart-locks-show-button", "disabled"),
        [Input("smart-locks-project-filter", "value")]
    )
    def toggle_show_button(project_id):
        return not project_id
    
    # Callback para habilitar/deshabilitar el botón de actualizar
    @app.callback(
        Output("smart-locks-refresh-button", "disabled"),
        [Input("smart-locks-data-store", "data")]
    )
    def toggle_refresh_button(data):
        return not data
    
    # Callback para obtener y almacenar datos de cerraduras
    @app.callback(
        [Output("smart-locks-data-store", "data"),
         Output("smart-locks-loading-indicator", "children")],
        [Input("smart-locks-show-button", "n_clicks"),
         Input("smart-locks-refresh-button", "n_clicks"),
         Input("smart-locks-refresh-trigger", "data")],
        [State("smart-locks-project-filter", "value"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[None, ""])
    def load_locks_data(show_clicks, refresh_clicks, refresh_trigger, project_id, token_data):
        if not project_id:
            return None, ""
        
        # Obtener el token JWT del store
        token = token_data.get('token') if token_data else None
        if not token:
            logger.error("No hay token JWT disponible para cargar cerraduras")
            return None, ""
        
        # PASO 1: Obtener los dispositivos a nivel de proyecto (Source A)
        project_devices = get_devices(
            project_id=project_id, 
            jwt_token=token, 
            device_types=["lock", "qr_lock"]  # Filtrar por tipos de cerradura en el servidor
        )
        
        # Filtrar dispositivos de proyecto por sensor para asegurar compatibilidad
        project_lock_devices = []
        for device in project_devices:
            has_lock_sensor = False
            has_community_door = False
            
            # Verificar ambos criterios de identificación
            for sensor in device.get("sensors", []):
                if sensor.get("sensor_type") == "LOCK":
                    has_lock_sensor = True
                if sensor.get("usage") == "CommunityDoor":
                    has_community_door = True
                    
            # Incluir el dispositivo si cumple al menos uno de los criterios
            if has_lock_sensor or has_community_door:
                # Añadir información de scope
                device["scope"] = {"type": "Project"}
                project_lock_devices.append(device)
        
        logger.info(f"Cargados {len(project_lock_devices)} dispositivos de cerradura a nivel de proyecto para {project_id}")
        
        # PASO 2a: Obtener la lista de assets/espacios del proyecto
        assets = get_project_assets(project_id, token)
        
        # PASO 2b: Obtener dispositivos para cada asset
        asset_lock_devices = []
        for asset in assets:
            asset_id = asset.get("id") or asset.get("asset_id")
            asset_name = asset.get("name") or asset.get("nombre")
            
            if not asset_id:
                logger.warning(f"No se pudo determinar el ID del asset: {asset}")
                continue
                
            # Obtener dispositivos del asset
            asset_devices = get_asset_devices(
                asset_id=asset_id,
                jwt_token=token,
                device_types="lock"  # Cambiado: solo usar "lock" para assets
            )
            
            # Añadir logging para diagnosticar el problema
            for i, device in enumerate(asset_devices):
                logger.debug(f"Dispositivo {i+1} de asset {asset_id}: {device}")
            
            # Procesar los dispositivos
            for device_container in asset_devices:
                # Verificar si el dispositivo tiene una estructura anidada con "devices"
                if isinstance(device_container, dict) and "devices" in device_container and isinstance(device_container["devices"], list):
                    # Procesar cada dispositivo dentro del array "devices"
                    logger.debug(f"Encontrado contenedor con {len(device_container['devices'])} dispositivos anidados")
                    
                    for nested_device in device_container["devices"]:
                        has_lock_sensor = False
                        device_id = nested_device.get("device_id", "desconocido")
                        
                        # Asegurarse de que el dispositivo tenga el asset_id
                        if "asset_id" not in nested_device and asset_id:
                            nested_device["asset_id"] = asset_id
                        
                        # Verificar sensores de cerradura en el dispositivo anidado
                        for sensor in nested_device.get("sensors", []):
                            logger.debug(f"Analizando sensor en dispositivo anidado {device_id}: tipo={sensor.get('sensor_type')}, usage={sensor.get('usage')}")
                            
                            if (sensor.get("sensor_type", "").upper() == "LOCK" or
                                sensor.get("type", "").upper() == "LOCK" or
                                sensor.get("usage") == "CommunityDoor" or
                                "lock" in str(sensor.get("sensor_type", "")).lower()):
                                has_lock_sensor = True
                                logger.debug(f"Dispositivo anidado {device_id} identificado como cerradura por su sensor")
                                break
                        
                        # Comprobar tipo de dispositivo
                        device_type = str(nested_device.get("device_type", "")).lower()
                        if not has_lock_sensor and ("lock" in device_type or "cerradura" in device_type):
                            has_lock_sensor = True
                            logger.debug(f"Dispositivo anidado {device_id} identificado como cerradura por su tipo: {device_type}")
                        
                        # Comprobar lock_type si existe
                        lock_type = nested_device.get("lock_type", "")
                        if not has_lock_sensor and lock_type:
                            has_lock_sensor = True
                            logger.debug(f"Dispositivo anidado {device_id} identificado como cerradura por su lock_type: {lock_type}")
                        
                        # Incluir dispositivo si se identificó como cerradura
                        if has_lock_sensor:
                            # Añadir información de scope
                            nested_device["scope"] = {
                                "type": "Asset",
                                "id": asset_id,
                                "name": asset_name
                            }
                            asset_lock_devices.append(nested_device)
                            logger.debug(f"Dispositivo anidado {device_id} añadido a la lista de cerraduras")
                else:
                    # Procesar dispositivo normal (no anidado)
                    has_lock_sensor = False
                    device_id = device_container.get("device_id", "desconocido")
                    
                    # Verificar sensores
                    for sensor in device_container.get("sensors", []):
                        logger.debug(f"Analizando sensor en dispositivo {device_id}: tipo={sensor.get('sensor_type')}, usage={sensor.get('usage')}")
                        
                        if (sensor.get("sensor_type", "").upper() == "LOCK" or
                            sensor.get("type", "").upper() == "LOCK" or
                            sensor.get("usage") == "CommunityDoor" or
                            "lock" in str(sensor.get("sensor_type", "")).lower()):
                            has_lock_sensor = True
                            logger.debug(f"Dispositivo {device_id} identificado como cerradura por su sensor")
                            break
                    
                    # Comprobar tipo de dispositivo
                    device_type = str(device_container.get("device_type", "")).lower()
                    if not has_lock_sensor and ("lock" in device_type or "cerradura" in device_type):
                        has_lock_sensor = True
                        logger.debug(f"Dispositivo {device_id} identificado como cerradura por su tipo: {device_type}")
                    
                    # Incluir dispositivo si se identificó como cerradura
                    if has_lock_sensor:
                        # Añadir información de scope
                        device_container["scope"] = {
                            "type": "Asset",
                            "id": asset_id,
                            "name": asset_name
                        }
                        asset_lock_devices.append(device_container)
                        logger.debug(f"Dispositivo {device_id} añadido a la lista de cerraduras")
                    else:
                        logger.debug(f"Dispositivo {device_id} NO reconocido como cerradura")
        
        logger.info(f"Cargados {len(asset_lock_devices)} dispositivos de cerradura a nivel de asset para {len(assets)} assets del proyecto {project_id}")
        
        # PASO 3: Consolidar los resultados
        consolidated_devices = []
        
        # Función para generar clave única para cada dispositivo
        def get_device_key(device):
            return device.get("device_id", "")
        
        # Primero añadir todos los dispositivos de nivel de asset
        device_keys = set()
        for device in asset_lock_devices:
            device_key = get_device_key(device)
            device_keys.add(device_key)
            consolidated_devices.append(device)
        
        # Luego añadir dispositivos de nivel de proyecto que no estén en los de asset
        for device in project_lock_devices:
            device_key = get_device_key(device)
            if device_key not in device_keys:
                consolidated_devices.append(device)
        
        logger.info(f"Total consolidado: {len(consolidated_devices)} dispositivos de cerradura para el proyecto {project_id}")
        
        return consolidated_devices, ""
    
    # Callback para actualizar el estado de una cerradura específica
    @app.callback(
        Output({"type": "lock-status", "index": ALL}, "children"),
        [Input("smart-locks-data-store", "data"),
         Input({"type": "lock-check-button", "index": ALL}, "n_clicks")],
        [State({"type": "lock-device-data", "index": ALL}, "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[])
    def update_lock_status(devices_data, check_clicks, device_data_list):
        # Si no hay datos de dispositivos, no hacer nada
        if not devices_data:
            return []
        
        # Obtener el contexto para saber qué cerradura se está actualizando
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        lock_statuses = []
        for device_data in device_data_list:
            device_id = device_data.get("device_id")
            
            # Buscar el dispositivo en los datos
            device = next((d for d in devices_data if d.get("device_id") == device_id), None)
            
            if not device:
                # Si no se encuentra el dispositivo, estado desconocido
                lock_statuses.append(html.Div([
                    html.I(className="fas fa-question-circle me-2"),
                    "Estado desconocido"
                ]))
                continue
            
            # En un caso real, aquí obtendríamos el estado actual de la cerradura desde la API
            # Por ahora, usamos un estado simulado
            lock_state = "LOCKED"  # Valores posibles: LOCKED, UNLOCKED, UNKNOWN
            
            if lock_state == "LOCKED":
                lock_statuses.append(html.Div([
                    html.I(className="fas fa-lock me-2 text-danger"),
                    "Bloqueada"
                ]))
            elif lock_state == "UNLOCKED":
                lock_statuses.append(html.Div([
                    html.I(className="fas fa-unlock me-2 text-success"),
                    "Desbloqueada"
                ]))
            else:
                lock_statuses.append(html.Div([
                    html.I(className="fas fa-question-circle me-2 text-warning"),
                    "Estado desconocido"
                ]))
        
        return lock_statuses
    
    # Callback para manejar acciones de bloqueo
    @app.callback(
        Output("smart-locks-confirm-modal", "is_open"),
        [Input({"type": "lock-button", "index": ALL}, "n_clicks"),
         Input({"type": "unlock-button", "index": ALL}, "n_clicks"),
         Input("smart-locks-confirm-cancel", "n_clicks"),
         Input("smart-locks-confirm-action", "n_clicks")],
        [State("smart-locks-confirm-modal", "is_open")],
        prevent_initial_call=True
    )
    def toggle_lock_confirm_modal(lock_clicks, unlock_clicks, cancel_clicks, confirm_clicks, is_open):
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        # Si el modal está abierto y se hace clic en Cancelar o Confirmar, cerrarlo
        if is_open and (cancel_clicks or confirm_clicks):
            return False
        
        # Si se hace clic en un botón de bloqueo/desbloqueo, abrir el modal
        if any(click for click in lock_clicks if click) or any(click for click in unlock_clicks if click):
            # En una implementación completa, aquí guardaríamos detalles sobre qué acción se está confirmando
            return True
        
        return is_open
    
    # Callback para abrir el modal de detalles al hacer clic en una tarjeta o fila
    @app.callback(
        [Output("smart-locks-modal", "is_open"),
         Output("smart-locks-modal-content", "children"),
         Output("smart-locks-modal-feedback", "children"),
         Output("current-device-store", "data")],
        [Input({"type": "lock-card", "index": ALL}, "n_clicks"),
         Input("smart-locks-table", "active_cell")],
        [State("smart-locks-table", "data"),
         State("smart-locks-data-store", "data"),
         State("smart-locks-modal", "is_open")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[False, "Error al cargar detalles", html.Div("Error al procesar datos", className="alert alert-danger"), None])
    def open_lock_details_modal(card_clicks, active_cell, table_data, devices_data, is_open):
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        # Si no hay trigger o no hay datos, no hacer nada
        if not triggered or triggered == '.' or not devices_data:
            return is_open, dash.no_update, dash.no_update, dash.no_update
        
        # Determinar qué dispositivo se ha seleccionado
        selected_device_id = None
        
        # Si el trigger fue un clic en una tarjeta
        if "lock-card" in triggered:
            import json
            # Extraer el índice del dispositivo de la tarjeta
            trigger_dict = json.loads(triggered.split('.')[0])
            selected_device_id = trigger_dict.get('index')
            
        # Si el trigger fue un clic en una fila de la tabla
        elif "smart-locks-table.active_cell" in triggered and active_cell:
            row_idx = active_cell['row']
            if table_data and row_idx < len(table_data):
                selected_device_id = table_data[row_idx]['id']
        
        # Si no se pudo determinar el dispositivo, no hacer nada
        if not selected_device_id:
            return is_open, dash.no_update, dash.no_update, dash.no_update
        
        # Buscar el dispositivo en los datos
        device = next((d for d in devices_data if d.get("device_id") == selected_device_id), None)
        
        if not device:
            return is_open, "No se encontró el dispositivo seleccionado", html.Div(
                "No se pudo encontrar información del dispositivo",
                className="alert alert-warning"
            ), None
            
        # Crear el contenido del modal con la información del dispositivo
        lock_sensor = None
        nfc_sensors = []
        
        # Añadir más logs para diagnosticar el problema
        logger.debug(f"Analizando dispositivo para modal: ID={selected_device_id}, tipo={device.get('device_type')}")
        logger.debug(f"Sensores disponibles en el dispositivo: {[s.get('sensor_type') for s in device.get('sensors', [])]}")
        
        # Buscar el sensor de cerradura y sensores NFC_CODE
        for sensor in device.get("sensors", []):
            if (sensor.get("sensor_type") == "LOCK" or sensor.get("usage") == "CommunityDoor") and not lock_sensor:
                lock_sensor = sensor
                logger.debug(f"Sensor de cerradura encontrado: {sensor.get('sensor_id')}")
            if sensor.get("sensor_type") == "NFC_CODE":
                nfc_sensors.append(sensor)
                logger.debug(f"Sensor NFC encontrado: {sensor.get('sensor_id')}")
        
        logger.info(f"Total de sensores NFC encontrados: {len(nfc_sensors)}")
        
        if not lock_sensor:
            return is_open, "Información de sensor no disponible", html.Div(
                "No se encontró información del sensor de cerradura",
                className="alert alert-warning"
            ), None
        
        # Extraer datos relevantes
        device_id = device.get("device_id", "Unknown")
        device_name = device.get("device_name", "Cerradura sin nombre")
        device_type = device.get("device_type", "UNKNOWN")
        connectivity = device.get("connectivity", "UNKNOWN")
        available_actions = device.get("available_actions", [])
        sensor_name = lock_sensor.get("name", "Cerradura")
        room = lock_sensor.get("room", "Desconocida")
        
        # Importante: Obtener el asset_id del dispositivo
        asset_id = device.get("asset_id")
        logger.debug(f"Asset ID del dispositivo: {asset_id}")
        
        # Determinar estado de conectividad
        if connectivity == "ONLINE":
            status_color = "success"
            status_text = "En línea"
        elif connectivity == "OFFLINE":
            status_color = "danger"
            status_text = "Fuera de línea"
        else:
            status_color = "warning"
            status_text = "Desconocido"
        
        # Determinar tipo de cerradura
        is_community_door = lock_sensor.get("usage") == "CommunityDoor"
        lock_type = "Puerta Comunitaria" if is_community_door else "Cerradura"
        
        # Crear los botones de acción según las acciones disponibles
        action_buttons = []
        
        # Botón de verificación remota
        if "remote_check" in available_actions:
            action_buttons.append(
                dbc.Button(
                    [html.I(className="fas fa-sync-alt me-2"), "Verificar Estado"],
                    id={"type": "modal-check-button", "index": device_id},
                    color="secondary",
                    className="me-2 mb-2",
                    size="md",
                )
            )
        
        # Botones de bloqueo/desbloqueo
        if "lock" in available_actions:
            action_buttons.append(
                dbc.Button(
                    [html.I(className="fas fa-lock me-2"), "Bloquear"],
                    id={"type": "modal-lock-button", "index": device_id},
                    color="danger",
                    className="me-2 mb-2",
                    size="md",
                )
            )
        
        if "unlock" in available_actions:
            action_buttons.append(
                dbc.Button(
                    [html.I(className="fas fa-unlock me-2"), "Desbloquear"],
                    id={"type": "modal-unlock-button", "index": device_id},
                    color="success",
                    className="me-2 mb-2",
                    size="md",
                )
            )
        
        # Botón de acceso a historial si está disponible
        if "access_logs" in available_actions:
            action_buttons.append(
                dbc.Button(
                    [html.I(className="fas fa-history me-2"), "Ver Historial"],
                    id={"type": "modal-history-button", "index": device_id},
                    color="info",
                    className="me-2 mb-2",
                    size="md",
                )
            )
        
        # Si hay actualización de software disponible
        if "software_update" in available_actions:
            action_buttons.append(
                dbc.Button(
                    [html.I(className="fas fa-download me-2"), "Actualizar Software"],
                    id={"type": "modal-update-button", "index": device_id},
                    color="primary",
                    className="me-2 mb-2",
                    size="md",
                )
            )
        
        # Preparar sección de códigos NFC si hay sensores de ese tipo
        nfc_section = []
        # Obtener el scope y asset_id del dispositivo
        scope = device.get("scope", {"type": "Project"})
        scope_type = scope.get("type", "Project")
        
        # Log de diagnóstico para el scope
        logger.debug(f"Scope del dispositivo: tipo={scope_type}, asset_id={asset_id}")
        
        # Ya no generamos la sección de NFC aquí, se generará dinámicamente desde el callback load_api_nfc_sensors
        # Solo actualizamos una variable para indicar si el dispositivo tiene asset_id y es de tipo Asset
        can_have_nfc = asset_id and scope_type == "Asset"
        if can_have_nfc:
            logger.debug(f"Dispositivo {device_id} cumple requisitos para mostrar NFC (asset_id={asset_id} y scope=Asset)")
        else:
            logger.warning(f"No se muestra sección NFC: asset_id={asset_id}, scope_type={scope_type}")
        
        # Determinar texto de scope para mostrar
        if scope_type == "Project":
            scope_text = "Proyecto"
            scope_badge_color = "primary"  # Azul para proyecto
        elif scope_type == "Asset":
            asset_name = scope.get("name", "Desconocido")
            scope_text = f"Espacio: {asset_name}"
            scope_badge_color = "success"  # Verde para asset/espacio
        else:
            scope_text = "Desconocido"
            scope_badge_color = "secondary"  # Gris para desconocido
        
        # Crear el contenido del modal
        modal_content = html.Div([
            # Cabecera con nombre y ubicación
            html.Div([
                html.H4(sensor_name, className="mb-2"),
                html.Div([
                    html.I(className="fas fa-map-marker-alt me-2", style={"color": "#3498db"}),
                    html.Span(room or "Ubicación desconocida", style={"fontStyle": "italic"})
                ], className="mb-3 py-1 px-2", style={
                    "backgroundColor": "#e8f4fc",
                    "borderRadius": "4px",
                    "display": "inline-block"
                })
            ], className="mb-2"),
            
            # Badge de scope/ámbito
            html.Div([
                html.Span(scope_text, className=f"badge bg-{scope_badge_color}")
            ], className="mb-4"),
            
            # Información del dispositivo
            dbc.Row([
                # Estado de conectividad
                dbc.Col([
                    html.Div([
                        html.H6("Estado de Conectividad", className="mb-2"),
                        html.Div([
                            html.I(className=f"fas fa-{'check-circle' if connectivity == 'ONLINE' else 'times-circle' if connectivity == 'OFFLINE' else 'question-circle'} me-2"),
                            html.Span(status_text, className=f"text-{status_color}")
                        ], className="d-flex align-items-center")
                    ], className="info-card p-3 mb-3", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], md=6),
                
                # Estado de la cerradura
                dbc.Col([
                    html.Div([
                        html.H6("Estado de Cerradura", className="mb-2"),
                        html.Div([
                            html.I(className="fas fa-question-circle me-2"),
                            "Desconocido"
                        ], id={"type": "modal-lock-status", "index": device_id}, className="d-flex align-items-center")
                    ], className="info-card p-3 mb-3", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], md=6)
            ]),
            
            # Detalles del dispositivo
            dbc.Row([
                dbc.Col([
                    html.Div([
                        html.H6("Detalles del Dispositivo", className="mb-2"),
                        html.Table([
                            html.Tbody([
                                html.Tr([
                                    html.Td("Tipo:", className="fw-bold pe-3"),
                                    html.Td(lock_type)
                                ]),
                                html.Tr([
                                    html.Td("Dispositivo:", className="fw-bold pe-3"),
                                    html.Td(device_type)
                                ]),
                                html.Tr([
                                    html.Td("ID:", className="fw-bold pe-3"),
                                    html.Td(device_id)
                                ])
                            ])
                        ], className="table table-sm")
                    ], className="info-card p-3 mb-4", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], md=12)
            ]),
            
            # Acciones disponibles
            html.Div([
                html.H5("Acciones", className="mb-3"),
                html.Div(action_buttons, className="d-flex flex-wrap")
            ]),
            
            # Sección de códigos NFC (si hay sensores)
            *nfc_section
        ])
        
        # Limpiar cualquier mensaje de feedback previo
        feedback = html.Div()
        
        # Guardar información relevante del dispositivo para uso en otros callbacks
        device_info = {
            "device_id": device_id,
            "asset_id": asset_id,
            "scope": scope
        }
        logger.info(f"Guardando información del dispositivo en current-device-store: {device_info}")
        
        # Abrir el modal o actualizarlo si ya está abierto
        return True, modal_content, feedback, device_info
    
    # Callback para actualizar el estado de la cerradura en el modal
    @app.callback(
        Output({"type": "modal-lock-status", "index": ALL}, "children"),
        [Input("smart-locks-modal", "is_open"),
         Input({"type": "modal-check-button", "index": ALL}, "n_clicks")],
        [State({"type": "modal-lock-status", "index": ALL}, "id"),
         State("smart-locks-data-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[])
    def update_modal_lock_status(is_open, check_clicks, status_ids, devices_data):
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        # Si no hay trigger o no está abierto el modal, no hacer nada
        if not triggered or not is_open:
            return dash.no_update
            
        # Preparar respuesta para cada status-id
        statuses = []
        for status_id in status_ids:
            device_id = status_id.get("index")
            
            # Encontrar el dispositivo en los datos
            device = next((d for d in devices_data if d.get("device_id") == device_id), None)
            
            if not device:
                statuses.append(html.Div([
                    html.I(className="fas fa-question-circle me-2 text-warning"),
                    "Estado desconocido"
                ], className="d-flex align-items-center"))
                continue
                
            # En un caso real, aquí se consultaría el estado actual
            # Por ahora, simulamos un estado de cerradura
            lock_state = "LOCKED"  # Valores posibles: LOCKED, UNLOCKED, UNKNOWN
            
            if lock_state == "LOCKED":
                statuses.append(html.Div([
                    html.I(className="fas fa-lock me-2 text-danger"),
                    "Bloqueada"
                ], className="d-flex align-items-center"))
            elif lock_state == "UNLOCKED":
                statuses.append(html.Div([
                    html.I(className="fas fa-unlock me-2 text-success"),
                    "Desbloqueada"
                ], className="d-flex align-items-center"))
            else:
                statuses.append(html.Div([
                    html.I(className="fas fa-question-circle me-2 text-warning"),
                    "Estado desconocido"
                ], className="d-flex align-items-center"))
        
        return statuses
    
    # Callback para actualizar el Store que activa la actualización de valores NFC
    @app.callback(
        Output("nfc-update-trigger", "data", allow_duplicate=True),
        [Input("nfc-edit-feedback", "children")],
        [State("nfc-update-trigger", "data")],
        prevent_initial_call=True
    )
    def update_nfc_trigger(feedback, current_data):
        # Si hay feedback y es un mensaje de éxito, activar el trigger
        if feedback:
            # En una implementación real, deberíamos verificar si el mensaje es de éxito
            # Por ahora, incrementamos un contador cada vez que hay feedback
            current_count = current_data.get("count", 0) if current_data else 0
            return {"updated": True, "count": current_count + 1}
        return current_data

    # Modificar el callback que carga los valores NFC para usar el nuevo endpoint
    @app.callback(
        Output({"type": "nfc-value", "index": ALL}, "children"),
        [Input("smart-locks-modal", "is_open"),
         Input("nfc-update-trigger", "data")],
        [State({"type": "nfc-sensor-data", "index": ALL}, "data"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[])
    def load_nfc_values(is_open, update_trigger, nfc_sensors_data, token_data):
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        # Si no hay trigger o no hay sensores, no hacer nada
        if not triggered or not nfc_sensors_data:
            return dash.no_update
            
        # Si el modal no está abierto y el trigger no es la actualización, no hacer nada
        if not is_open and "nfc-update-trigger" not in triggered:
            return dash.no_update
        
        # Obtener el token JWT
        token = token_data.get('token') if token_data else None
        if not token:
            logger.error("No hay token JWT disponible para cargar valores NFC")
            return ["N/A" for _ in nfc_sensors_data]
        
        # Valores a mostrar para cada sensor
        nfc_values = []
        
        # Cache para las respuestas de la API por asset_id
        nfc_passwords_cache = {}
        
        # Agrupar sensores por asset_id para reducir las llamadas a la API
        sensors_by_asset = {}
        for sensor_data in nfc_sensors_data:
            if not isinstance(sensor_data, dict):
                continue
            
            asset_id = sensor_data.get("asset_id")
            if asset_id:
                if asset_id not in sensors_by_asset:
                    sensors_by_asset[asset_id] = []
                sensors_by_asset[asset_id].append(sensor_data)
                
        logger.debug(f"Agrupados {len(nfc_sensors_data)} sensores en {len(sensors_by_asset)} assets")
        
        # Obtener los valores para cada sensor NFC
        for sensor_data in nfc_sensors_data:
            if not isinstance(sensor_data, dict):
                nfc_values.append("N/A")
                continue
                
            device_id = sensor_data.get("device_id")
            sensor_id = sensor_data.get("sensor_id")
            asset_id = sensor_data.get("asset_id")
            scope = sensor_data.get("scope", {"type": "Project"})
            
            # CAMBIO: Verificar si el dispositivo está asociado a un asset
            # Solo cargar NFC para dispositivos asociados a un asset
            if not asset_id or scope.get("type") != "Asset":
                nfc_values.append("No disponible para este tipo de cerradura")
                continue
            
            if not device_id or not sensor_id:
                nfc_values.append("N/A")
                continue
            
            try:
                # Obtener o cargar del cache los datos de passwords NFC
                if asset_id not in nfc_passwords_cache:
                    logger.info(f"Obteniendo datos NFC para asset_id {asset_id}")
                    nfc_passwords_cache[asset_id] = get_nfc_passwords(asset_id, token)
                
                nfc_passwords_data = nfc_passwords_cache[asset_id]
                
                # Log de depuración para ver el formato de los datos
                logger.debug(f"Datos NFC para {asset_id}: Tipo={type(nfc_passwords_data)}")
                
                if not nfc_passwords_data:
                    logger.warning(f"No se encontraron datos NFC para asset_id {asset_id}")
                    nfc_values.append("No disponible")
                    continue
                
                # Verificar si los datos tienen el formato esperado
                if isinstance(nfc_passwords_data, dict) and 'data' in nfc_passwords_data:
                    data_section = nfc_passwords_data['data']
                    
                    # Inicializar el valor de la contraseña
                    password_value = "No disponible"
                    
                    # Obtener los dispositivos de diferentes formatos posibles
                    devices = []
                    
                    # CASO 1: data es un diccionario con la clave 'devices'
                    if isinstance(data_section, dict) and 'devices' in data_section:
                        if isinstance(data_section['devices'], list):
                            devices = data_section['devices']
                            logger.debug(f"Encontrados {len(devices)} dispositivos en formato estándar")
                    
                    # CASO 2: data es directamente una lista de dispositivos
                    elif isinstance(data_section, list):
                        devices = data_section
                        logger.debug(f"Encontrados {len(devices)} dispositivos en formato de lista")
                    
                    # CASO 3: data es un único dispositivo (diccionario con device_id)
                    elif isinstance(data_section, dict) and 'device_id' in data_section:
                        devices = [data_section]
                        logger.debug("Encontrado un único dispositivo")
                        
                    # Si no se pudo determinar el formato o no hay dispositivos
                    if not devices:
                        logger.error(f"No se pudieron extraer dispositivos del formato: {type(data_section)}")
                        nfc_values.append("N/A")
                        continue
                
                    # Log para depuración de dispositivos
                    device_ids = [dev.get('device_id') for dev in devices if isinstance(dev, dict)]
                    logger.debug(f"Dispositivos disponibles: {device_ids}")
                    
                    # Buscar el dispositivo correspondiente
                    device_found = False
                    for dev in devices:
                        if not isinstance(dev, dict):
                            logger.warning(f"Dispositivo no es un diccionario sino {type(dev)}")
                            continue
                        
                        dev_id = str(dev.get('device_id', ''))
                        requested_id = str(device_id)
                        logger.debug(f"Comparando device_id: API={dev_id}, Solicitado={requested_id}")
                        
                        if dev_id == requested_id:
                            device_found = True
                            # Validar sensor_passwords
                            sensor_passwords = dev.get('sensor_passwords', [])
                            if not isinstance(sensor_passwords, list):
                                logger.warning(f"'sensor_passwords' no es una lista sino {type(sensor_passwords)}")
                                continue
                                
                            logger.debug(f"Encontrado dispositivo {dev_id} con {len(sensor_passwords)} sensores")
                            
                            # Buscar el sensor correspondiente
                            sensor_found = False
                            for sensor_pw in sensor_passwords:
                                if not isinstance(sensor_pw, dict):
                                    logger.warning(f"Contraseña de sensor no es un diccionario sino {type(sensor_pw)}")
                                    continue
                                
                                # Comprobar ambos como strings para evitar problemas de tipo
                                pw_sensor_id = str(sensor_pw.get('sensor_id', ''))
                                requested_sensor_id = str(sensor_id)
                                logger.debug(f"Comparando sensor_id: API={pw_sensor_id}, Solicitado={requested_sensor_id}")
                                
                                if pw_sensor_id == requested_sensor_id:
                                    sensor_found = True
                                    password_value = sensor_pw.get('password', "")
                                    logger.info(f"Encontrado sensor {pw_sensor_id} con valor: {password_value}")
                                    break
                            
                            if not sensor_found:
                                logger.warning(f"No se encontró el sensor {sensor_id} en el dispositivo {device_id}")
                                password_value = "No encontrado"
                            break
                    
                    if not device_found:
                        logger.warning(f"No se encontró el dispositivo {device_id} en la respuesta de la API")
                        password_value = "Dispositivo no encontrado"
                
                    # Si no hay password o está vacío, mostrar "No asignado"
                    if password_value == "":
                        password_value = "No asignado"
                    
                    nfc_values.append(password_value)
                    logger.debug(f"Valor NFC obtenido para sensor {sensor_id}: {password_value}")
                else:
                    logger.error(f"Formato de datos NFC inesperado: {type(nfc_passwords_data)}. No contiene clave 'data'")
                    nfc_values.append("N/A")
                
            except Exception as e:
                logger.error(f"Error al obtener valor NFC: {str(e)}")
                nfc_values.append("Error")
        
        return nfc_values
    
    # Callback para abrir el modal de edición de código NFC
    @app.callback(
        [Output("nfc-edit-modal", "is_open"),
         Output("nfc-edit-info", "children"),
         Output("nfc-edit-value-input", "value"),
         Output("nfc-edit-feedback", "children"),
         Output("nfc-edit-success-timer", "disabled")],
        [Input({"type": "nfc-edit-button", "index": ALL}, "n_clicks"),
         Input("nfc-edit-cancel", "n_clicks"),
         Input("nfc-edit-save", "n_clicks")],
        [State({"type": "nfc-edit-button", "index": ALL}, "id"),
         State({"type": "nfc-sensor-data", "index": ALL}, "data"),
         State({"type": "nfc-value", "index": ALL}, "children"),
         State("nfc-edit-modal", "is_open"),
         State("nfc-edit-value-input", "value"),
         State("jwt-token-store", "data"),
         State("current-device-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[False, "", "", "", True])
    def handle_nfc_edit_modal(edit_clicks, cancel_clicks, save_clicks, button_ids, sensor_data_list, current_values, is_open, input_value, token_data, current_device):
        ctx = dash.callback_context
        triggered = ctx.triggered[0]['prop_id'] if ctx.triggered else None
        
        # Si no hay trigger, no hacer nada
        if not triggered or triggered == '.':
            return is_open, dash.no_update, dash.no_update, dash.no_update, True
        
        # Si se cancela la edición
        if "nfc-edit-cancel" in triggered and cancel_clicks:
            return False, "", "", "", True
        
        # Si se hace clic en editar
        if "nfc-edit-button" in triggered:
            import json
            trigger_id = json.loads(triggered.split('.')[0])
            button_index = trigger_id.get('index')
            
            logger.debug(f"Botón de edición pulsado con índice: {button_index}")
            
            # Buscar el botón que se ha pulsado y el sensor correspondiente
            selected_sensor = None
            current_value = ""
            
            # Logging para depurar el problema
            logger.debug(f"Total de sensores disponibles: {len(sensor_data_list)}")
            
            for i, button_id in enumerate(button_ids):
                if i < len(sensor_data_list):
                    logger.debug(f"Sensor data {i}: {sensor_data_list[i]}")
                
                if button_id.get('index') == button_index and i < len(sensor_data_list):
                    selected_sensor = sensor_data_list[i]
                    logger.debug(f"Sensor seleccionado: {selected_sensor}")
                    
                    if i < len(current_values):
                        current_value = current_values[i]
                    break
            
            if not selected_sensor:
                logger.error(f"No se encontró el sensor correspondiente al botón {button_index}")
                return is_open, dash.no_update, dash.no_update, html.Div(
                    "Error: No se pudo recuperar la información del sensor",
                    className="alert alert-danger"
                ), True
            
            # Verificar que el sensor tenga todos los datos necesarios
            device_id = selected_sensor.get('device_id')
            sensor_id = selected_sensor.get('sensor_id')
            asset_id = selected_sensor.get('asset_id')
            
            # Si falta el asset_id, intentar obtenerlo del current-device-store
            if (not asset_id or asset_id == "No disponible") and current_device:
                asset_id = current_device.get('asset_id')
                selected_sensor['asset_id'] = asset_id
                logger.debug(f"Se usó el asset_id del current-device-store: {asset_id}")
            
            logger.debug(f"Verificando datos para edición - device_id: {device_id}, sensor_id: {sensor_id}, asset_id: {asset_id}")
            
            if not device_id or not sensor_id or not asset_id:
                logger.error(f"Faltan datos críticos del sensor - device_id: {device_id}, sensor_id: {sensor_id}, asset_id: {asset_id}")
                return is_open, dash.no_update, dash.no_update, html.Div(
                    "Error: Datos incompletos del sensor",
                    className="alert alert-danger"
                ), True
            
            # Información del sensor para mostrar en el modal
            sensor_info = html.Div([
                html.H6("Sensor:", className="mb-2"),
                html.Table([
                    html.Tbody([
                        html.Tr([
                            html.Td("Nombre:", className="fw-bold pe-3"),
                            html.Td(selected_sensor.get("name"))
                        ]),
                        html.Tr([
                            html.Td("ID Sensor:", className="fw-bold pe-3"),
                            html.Td(selected_sensor.get("sensor_id"))
                        ]),
                        html.Tr([
                            html.Td("Ubicación:", className="fw-bold pe-3"),
                            html.Td(selected_sensor.get("room") or "No especificada")
                        ])
                    ])
                ], className="table table-sm")
            ])
            
            # Guardar los datos del sensor en un hidden div para usarlos al guardar
            sensor_info_with_data = html.Div([
                sensor_info,
                dcc.Store(
                    id="nfc-editing-sensor-data",
                    data=selected_sensor
                )
            ])
            
            return True, sensor_info_with_data, current_value, "", True
        
        # Si se guarda la edición
        if "nfc-edit-save" in triggered and save_clicks:
            # Obtener los datos del sensor que se está editando
            editing_sensor_data = {}
            
            # En Dash 2.0+, ctx.states es un diccionario de todos los estados
            all_states = ctx.states
            
            # Buscar el estado con ID 'nfc-editing-sensor-data'
            for state_id, state_value in all_states.items():
                if 'nfc-editing-sensor-data' in state_id:
                    logger.debug(f"Encontrado estado de edición: {state_id}")
                    editing_sensor_data = state_value.get('data', {})
                    break
            
            # Si no lo encontramos por el ID completo, buscar por substring
            if not editing_sensor_data:
                for state_id, state_value in all_states.items():
                    if 'nfc-editing-sensor-data' in state_id:
                        editing_sensor_data = state_value
                        break
            
            # Agregar logs para diagnosticar el problema
            logger.debug(f"Datos para guardar NFC: {editing_sensor_data}")
            
            # Obtener los IDs necesarios con valores por defecto para depuración
            device_id = editing_sensor_data.get("device_id", "No disponible")
            sensor_id = editing_sensor_data.get("sensor_id", "No disponible") 
            asset_id = editing_sensor_data.get("asset_id", "No disponible")
            
            # Si falta el asset_id, intentar obtenerlo del current-device-store
            if (not asset_id or asset_id == "No disponible") and current_device:
                asset_id = current_device.get('asset_id')
                editing_sensor_data['asset_id'] = asset_id
                logger.debug(f"Se usó el asset_id del current-device-store: {asset_id}")
            
            # Logging detallado para diagnóstico
            logger.debug(f"Guardando NFC - device_id: {device_id}, sensor_id: {sensor_id}, asset_id: {asset_id}")
            
            # Imprimir todos los estados disponibles para debug
            logger.debug("Estados disponibles en el contexto:")
            for k, v in all_states.items():
                logger.debug(f"  - {k}: {v if not isinstance(v, dict) else 'dict'}")
                
            # Si editing_sensor_data está vacío, intentar reconstruir los datos desde otros estados
            if not editing_sensor_data or not device_id or device_id == "No disponible":
                # Intentar obtener datos del botón que se pulsó
                for k, v in all_states.items():
                    if 'nfc-edit-button' in k and isinstance(v, dict) and 'index' in v:
                        button_index = v.get('index')
                        if button_index:
                            logger.debug(f"Intentando reconstruir datos desde el botón: {button_index}")
                            parts = button_index.split('_')
                            # Formato antiguo: device_id_sensor_id
                            if len(parts) == 2:
                                device_id = parts[0]
                                sensor_id = parts[1]
                                # Si tenemos un current_device, usamos su asset_id
                                if current_device and current_device.get('device_id') == device_id:
                                    asset_id = current_device.get('asset_id')
                                    logger.debug(f"Usando asset_id={asset_id} del current-device-store")
                                # Si no, buscamos el asset_id como antes
                                else:
                                    for asset_k, asset_v in all_states.items():
                                        if 'smart-locks-data-store' in asset_k and asset_v:
                                            # Buscar el dispositivo en los datos
                                            devices = asset_v if isinstance(asset_v, list) else []
                                            for dev in devices:
                                                if dev.get('device_id') == device_id:
                                                    asset_id = dev.get('asset_id')
                                                    logger.debug(f"Reconstruido asset_id: {asset_id}")
                                                    break
                            # Nuevo formato: device_id_sensor_id_asset_id
                            elif len(parts) >= 3:
                                device_id = parts[0]
                                sensor_id = parts[1]
                                asset_id = parts[2]
                                logger.debug(f"Extraído asset_id={asset_id} directamente del índice del botón")
                            break
            
            # Validar que hay un valor
            if not input_value or input_value.strip() == "":
                return True, dash.no_update, dash.no_update, html.Div(
                    "El valor no puede estar vacío",
                    className="alert alert-danger"
                ), True
            
            # Validar que tenemos los datos necesarios
            if not device_id or device_id == "No disponible":
                return True, dash.no_update, dash.no_update, html.Div(
                    f"Falta el ID del dispositivo (device_id: {device_id})",
                    className="alert alert-danger"
                ), True
            
            if not sensor_id or sensor_id == "No disponible":
                return True, dash.no_update, dash.no_update, html.Div(
                    f"Falta el ID del sensor (sensor_id: {sensor_id})",
                    className="alert alert-danger"
                ), True
                
            if not asset_id or asset_id == "No disponible":
                return True, dash.no_update, dash.no_update, html.Div(
                    f"Falta el ID del asset (asset_id: {asset_id})",
                    className="alert alert-danger"
                ), True
            
            try:
                # Obtener el token JWT
                token = token_data.get('token') if token_data else None
                
                if not token:
                    logger.error("No hay token JWT disponible para actualizar valor NFC")
                    return True, dash.no_update, dash.no_update, html.Div(
                        "No hay autenticación disponible para actualizar el valor",
                        className="alert alert-danger"
                    ), True
                
                # Actualizar el valor del código NFC usando la nueva API
                # Usamos el endpoint correcto según la documentación
                gateway_id = device_id  # Por defecto, usar device_id como gateway_id
                logger.debug(f"Actualizando código NFC - asset_id: {asset_id}, device_id: {device_id}, sensor_id: {sensor_id}, valor: {input_value}")
                success, response = update_nfc_code_value(
                    asset_id=asset_id, 
                    device_id=device_id, 
                    sensor_id=sensor_id, 
                    new_value=input_value, 
                    jwt_token=token,
                    gateway_id=gateway_id  # Pasamos el gateway_id (que es igual al device_id en este caso)
                )
                
                if success:
                    # Mensaje de éxito
                    success_message = html.Div(
                        "Código NFC actualizado correctamente",
                        className="alert alert-success"
                    )
                    
                    # Activar el timer para cerrar el modal automáticamente
                    return True, dash.no_update, dash.no_update, success_message, False
                else:
                    # Mensaje de error
                    error_details = response.get("error", "Error desconocido")
                    error_message = html.Div(
                        f"Error al actualizar el código NFC: {error_details}",
                        className="alert alert-danger"
                    )
                    return True, dash.no_update, dash.no_update, error_message, True
            except Exception as e:
                error_message = html.Div(
                    f"Error al actualizar el código NFC: {str(e)}",
                    className="alert alert-danger"
                )
                return True, dash.no_update, dash.no_update, error_message, True
        
        return is_open, dash.no_update, dash.no_update, dash.no_update, True
    
    # Callbacks adicionales para las acciones del modal podrían implementarse aquí
    # - Verificar estado
    # - Bloquear/desbloquear
    # - Ver historial
    # - Actualizar software
    
    # Callback para cerrar el modal
    @app.callback(
        [Output("smart-locks-modal", "is_open", allow_duplicate=True),
         Output("current-device-store", "data", allow_duplicate=True)],
        [Input("smart-locks-modal-close", "n_clicks")],
        [State("smart-locks-modal", "is_open")],
        prevent_initial_call=True
    )
    def close_details_modal(n_clicks, is_open):
        if n_clicks and is_open:
            return False, None
        return is_open, dash.no_update
    
    # Callback para cerrar el modal de edición después de una actualización exitosa
    @app.callback(
        [Output("nfc-edit-modal", "is_open", allow_duplicate=True),
         Output("nfc-edit-success-timer", "disabled", allow_duplicate=True)],
        [Input("nfc-edit-success-timer", "n_intervals")],
        [State("nfc-edit-feedback", "children")],
        prevent_initial_call=True
    )
    def close_nfc_edit_modal_after_success(n_intervals, feedback_content):
        # Solo cerrar si hay intervalos (timer activado) y hay un mensaje de éxito
        if n_intervals and feedback_content:
            # En una implementación real, deberíamos verificar si el feedback es de éxito
            # Esto se podría hacer guardando un indicador en un dcc.Store
            return False, True  # Cerrar el modal y desactivar el timer
        return dash.no_update, dash.no_update

    # Callback para crear sensores NFC virtuales a partir de los datos de la API
    @app.callback(
        Output("smart-locks-refresh-trigger", "data", allow_duplicate=True),
        [Input("smart-locks-modal", "is_open")],
        [State("smart-locks-modal-content", "children"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return={"refreshed": False})
    def create_virtual_nfc_sensors(is_open, modal_content, token_data):
        """
        Este callback se activa cuando se abre el modal y crea sensores NFC virtuales
        a partir de los datos de la API para los dispositivos que no tienen sensores
        NFC explícitamente definidos.
        """
        if not is_open or not modal_content:
            return dash.no_update
        
        ctx = dash.callback_context
        if not ctx.triggered:
            return dash.no_update
            
        # Obtener el token JWT
        token = token_data.get('token') if token_data else None
        if not token:
            logger.error("No hay token JWT disponible para crear sensores virtuales")
            return dash.no_update
            
        try:
            # Este callback solo observa cambios, no necesita hacer nada más
            # El callback load_nfc_values ya cargará los valores cuando se abra el modal
            return {"refreshed": True, "timestamp": time.time()}
        except Exception as e:
            logger.error(f"Error al crear sensores virtuales: {str(e)}")
            return dash.no_update

    # Callback para cargar y mostrar dinámicamente los sensores NFC
    @app.callback(
        Output("smart-locks-modal-feedback", "children", allow_duplicate=True),
        [Input("smart-locks-modal", "is_open"),
         Input("smart-locks-refresh-trigger", "data")],
        [State("smart-locks-data-store", "data"),
         State("smart-locks-modal", "children"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=html.Div())
    def load_api_nfc_sensors(is_open, refresh_trigger, devices_data, modal_children, token_data):
        ctx = dash.callback_context
        if not ctx.triggered or not is_open:
            return dash.no_update
            
        # Obtener el token JWT
        token = token_data.get('token') if token_data else None
        if not token:
            logger.error("No hay token JWT disponible para cargar sensores NFC")
            return dash.no_update
            
        # Intentar obtener el asset_id y device_id del modal actual
        asset_id = None
        device_id = None
        
        # Buscar un elemento con id que contenga "modal-lock-status"
        # Este elemento contiene el device_id como parte de su índice
        try:
            modal_content = modal_children[1] if isinstance(modal_children, list) and len(modal_children) > 1 else None
            if modal_content and 'props' in modal_content and 'children' in modal_content['props']:
                for child in modal_content['props']['children']:
                    if not isinstance(child, dict):
                        continue
                    
                    # Buscar recursivamente objetos con "id" que contengan "modal-lock-status"
                    def find_device_id(obj):
                        if isinstance(obj, dict):
                            if 'props' in obj and 'id' in obj['props']:
                                id_prop = obj['props']['id']
                                if isinstance(id_prop, dict) and id_prop.get('type') == 'modal-lock-status':
                                    return id_prop.get('index')
                            
                            # Buscar en hijos
                            for key, value in obj.items():
                                if key == 'props' and 'children' in value:
                                    result = find_device_id_in_children(value['children'])
                                    if result:
                                        return result
                        return None
                    
                    def find_device_id_in_children(children):
                        if isinstance(children, list):
                            for child in children:
                                result = find_device_id(child)
                                if result:
                                    return result
                        else:
                            return find_device_id(children)
                        return None
                    
                    device_id = find_device_id(child)
                    if device_id:
                        break
        except Exception as e:
            logger.error(f"Error al buscar device_id en el modal: {str(e)}")
            return dash.no_update
        
        if not device_id:
            logger.warning("No se pudo determinar el dispositivo actual del modal")
            return dash.no_update
            
        # Buscar el dispositivo en los datos para obtener el asset_id
        device = next((d for d in devices_data if d.get("device_id") == device_id), None)
        if not device:
            logger.warning(f"No se encontró el dispositivo {device_id} en los datos")
            return dash.no_update
            
        asset_id = device.get("asset_id")
        if not asset_id:
            logger.warning(f"El dispositivo {device_id} no tiene asset_id")
            return dash.no_update
            
        # Comprobar si el dispositivo ya tiene sensores NFC
        has_nfc_sensors = False
        for sensor in device.get("sensors", []):
            if sensor.get("sensor_type") == "NFC_CODE":
                has_nfc_sensors = True
                break
                
        if has_nfc_sensors:
            logger.debug(f"El dispositivo {device_id} ya tiene sensores NFC, no se cargan desde la API")
            return dash.no_update
            
        # Intentar cargar los sensores NFC de la API
        try:
            logger.info(f"Cargando sensores NFC de la API para asset_id {asset_id}")
            nfc_data = get_nfc_passwords(asset_id, token)
            
            if not nfc_data or not isinstance(nfc_data, dict) or 'data' not in nfc_data:
                logger.warning(f"No se obtuvieron datos NFC válidos para {asset_id}")
                return html.Div([
                    html.H5("Códigos NFC", className="mb-3"),
                    html.Div([
                        html.P([
                            html.I(className="fas fa-info-circle me-2 text-info"),
                            "No hay códigos NFC disponibles para este dispositivo."
                        ])
                    ], className="info-card p-3 mb-4", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], className="mt-4")
                
            data_section = nfc_data['data']
            devices = []
            
            # Extraer dispositivos según el formato
            if isinstance(data_section, dict) and 'devices' in data_section:
                devices = data_section['devices']
            elif isinstance(data_section, list):
                devices = data_section
            else:
                logger.warning(f"Formato inesperado de datos NFC: {type(data_section)}")
                return dash.no_update
                
            # Filtrar dispositivos que coincidan con el device_id
            matching_devices = []
            for dev in devices:
                dev_id = str(dev.get('device_id', ''))
                if dev_id == str(device_id):
                    matching_devices.append(dev)
                    
            if not matching_devices:
                logger.warning(f"No se encontraron dispositivos con ID {device_id} en los datos NFC")
                return html.Div([
                    html.H5("Códigos NFC", className="mb-3"),
                    html.Div([
                        html.P([
                            html.I(className="fas fa-info-circle me-2 text-info"),
                            "No hay códigos NFC disponibles para este dispositivo."
                        ])
                    ], className="info-card p-3 mb-4", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], className="mt-4")
                
            # Extraer sensores NFC de los dispositivos coincidentes
            nfc_rows = []
            for dev in matching_devices:
                sensor_passwords = dev.get('sensor_passwords', [])
                for sensor_pw in sensor_passwords:
                    if not isinstance(sensor_pw, dict):
                        continue
                        
                    # Solo procesar sensores NFC_CODE
                    if sensor_pw.get('sensor_type') != 'NFC_CODE':
                        continue
                        
                    sensor_id = str(sensor_pw.get('sensor_id', ''))
                    password = sensor_pw.get('password', '')
                    
                    logger.debug(f"Añadiendo sensor NFC de la API: device_id={device_id}, sensor_id={sensor_id}, asset_id={asset_id}")
                    
                    # Datos del sensor para el store con todos los campos necesarios
                    sensor_data = {
                        "device_id": device_id,
                        "sensor_id": sensor_id,
                        "sensor_uuid": "",
                        "name": f"NFC Code {sensor_id}",
                        "room": "",
                        "asset_id": asset_id,
                        "scope": device.get("scope", {"type": "Asset"})
                    }
                    
                    # Verificar que todos los datos críticos estén presentes
                    logger.debug(f"Datos del sensor guardados: device_id={sensor_data['device_id']}, sensor_id={sensor_data['sensor_id']}, asset_id={sensor_data['asset_id']}")
                    
                    # Añadir fila para el sensor NFC
                    nfc_rows.append(
                        html.Tr([
                            html.Td(sensor_id),
                            html.Td(f"NFC Code {sensor_id}"),
                            html.Td("-"),
                            html.Td(password if password else "No asignado"),
                            html.Td([
                                dbc.Button(
                                    html.I(className="fas fa-edit"),
                                    id={"type": "nfc-edit-button", "index": f"{device_id}_{sensor_id}_{asset_id}"},
                                    color="link",
                                    size="sm",
                                    className="p-0",
                                    title="Editar código NFC"
                                ),
                                # Store para guardar información del sensor NFC
                                dcc.Store(
                                    id={"type": "nfc-sensor-data", "index": f"{device_id}_{sensor_id}"},
                                    data=sensor_data
                                )
                            ])
                        ])
                    )
            
            if not nfc_rows:
                logger.warning(f"No se encontraron sensores NFC para el dispositivo {device_id}")
                return html.Div([
                    html.H5("Códigos NFC", className="mb-3"),
                    html.Div([
                        html.P([
                            html.I(className="fas fa-info-circle me-2 text-info"),
                            "Este dispositivo no tiene códigos NFC configurados."
                        ])
                    ], className="info-card p-3 mb-4", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
                ], className="mt-4")
                
            # Crear la sección de NFC Codes
            nfc_section = html.Div([
                html.H5("Códigos NFC", className="mb-3"),
                html.Div([
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("ID", className="fw-bold"),
                                html.Th("Nombre", className="fw-bold"),
                                html.Th("Ubicación", className="fw-bold"),
                                html.Th("Valor Actual", className="fw-bold"),
                                html.Th("Acciones", className="fw-bold"),
                            ])
                        ]),
                        html.Tbody(nfc_rows)
                    ], className="table table-striped table-hover")
                ], className="info-card p-3 mb-4", style={"border": "1px solid #dee2e6", "borderRadius": "8px"})
            ], className="mt-4")
            
            return nfc_section
            
        except Exception as e:
            logger.error(f"Error al cargar sensores NFC de la API: {str(e)}")
            return dash.no_update 
    
    # Callback combinado para mostrar la matriz NFC o la matriz por tipo
    @app.callback(
        Output("nfc-grid-container", "children"),
        [Input("smart-locks-tabs", "active_tab"),
         Input("smart-locks-data-store", "data"),
         Input("smart-locks-type-filter", "value")],
        prevent_initial_call=False
    )
    @handle_exceptions(default_return=html.Div("Error al cargar la matriz", className="alert alert-danger"))
    def update_grid_display(active_tab, devices_data, selected_type):
        ctx = callback_context
        triggered_id = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None
        
        # Si la pestaña no es la de matriz, devolver un contenedor vacío
        if active_tab != "nfc-grid-tab":
            return html.Div()
        
        # Si no hay datos, mostrar mensaje informativo
        if not devices_data:
            return html.Div([
                html.I(className="fas fa-info-circle me-2"),
                "Seleccione un proyecto y haga clic en 'Mostrar Cerraduras' para ver la matriz."
            ], className="alert alert-info")
        
        # Preprocesar las cerraduras para añadir información específica de NFC si está disponible
        # Este paso ayuda a que el grid detecte correctamente los sensores NFC
        processed_devices = []
        nfc_sensor_count = 0
        devices_with_nfc = 0
        
        for device in devices_data:
            # Crear una copia para no modificar los datos originales
            processed_device = device.copy()
            device_has_nfc = False
            
            # Verificar si tiene asset_id para poder cargar códigos NFC
            asset_id = processed_device.get("asset_id")
            if asset_id:
                # Buscar sensores NFC existentes primero
                for sensor in processed_device.get("sensors", []):
                    if sensor and sensor.get("sensor_type") == "NFC_CODE":
                        # Este es un sensor NFC explícito
                        sensor["is_potential_nfc"] = True
                        nfc_sensor_count += 1
                        device_has_nfc = True
                        # Añadir el valor NFC si existe
                        password = sensor.get("password", "")
                        nfc_password = sensor.get("nfc_password", "")
                        nfc_code = sensor.get("nfc_code", "")
                        if password or nfc_password or nfc_code:
                            sensor["nfc_value"] = password or nfc_password or nfc_code
                
                # Si no se encontraron sensores NFC, buscar potenciales sensores que podrían ser NFC
                if not device_has_nfc:
                    # Marcar sensores que pueden ser NFC
                    for sensor in processed_device.get("sensors", []):
                        if sensor and (
                            "NFC" in str(sensor.get("name", "")).upper() or
                            "CODE" in str(sensor.get("name", "")).upper() or
                            "CÓDIGO" in str(sensor.get("name", "")).upper() or
                            "TARJETA" in str(sensor.get("name", "")).upper() or
                            "CARD" in str(sensor.get("name", "")).upper()
                        ):
                            # Añadir una marca para que se detecte como NFC potencial
                            sensor["is_potential_nfc"] = True
                            nfc_sensor_count += 1
                            device_has_nfc = True
                            
                            # Intentar extraer información de código NFC si existe
                            password = sensor.get("password", "")
                            nfc_password = sensor.get("nfc_password", "")
                            nfc_code = sensor.get("nfc_code", "")
                            
                            # Si hay un código disponible, guardarlo para mostrar inmediatamente
                            if password or nfc_password or nfc_code:
                                sensor["nfc_value"] = password or nfc_password or nfc_code
                
                # Si aún no hay sensors NFC detectados, y el dispositivo es una cerradura,
                # crearemos "sensores virtuales" para ser rellenados desde la API
                if not device_has_nfc:
                    # Verificar si es una cerradura
                    is_lock = False
                    for sensor in processed_device.get("sensors", []):
                        if sensor and sensor.get("sensor_type") == "LOCK":
                            is_lock = True
                            break
                    
                    # Comentamos la creación de sensores virtuales
                    """
                    # Si es una cerradura, añadir sensores virtuales
                    if is_lock:
                        # Si no hay sensores, inicializar la lista
                        if "sensors" not in processed_device or not processed_device["sensors"]:
                            processed_device["sensors"] = []
                        
                        # Crear un sensor NFC virtual
                        virtual_sensor = {
                            "sensor_id": f"virtual_nfc_{processed_device.get('device_id', '')}",
                            "sensor_type": "NFC_CODE",
                            "name": "Código NFC Virtual",
                            "is_potential_nfc": True,
                            "is_virtual": True
                        }
                        
                        # Añadir el sensor virtual a la lista de sensores
                        processed_device["sensors"].append(virtual_sensor)
                        nfc_sensor_count += 1
                        device_has_nfc = True
                        logger.debug(f"Añadido sensor NFC virtual para dispositivo {processed_device.get('device_id', '')}")
                    """
            
            if device_has_nfc:
                devices_with_nfc += 1
            
            processed_devices.append(processed_device)
        
        # Contenedor para la matriz NFC
        nfc_grid = create_nfc_display_grid(filtered_locks=processed_devices, is_loading_locks=False, show_all_sensors=True)
        
        # Añadir información sobre la detección de sensores NFC
        info_section = html.Div([
            html.H4("Matriz de Códigos NFC", className="mb-3"),
            html.Div([
                html.P([
                    html.I(className="fas fa-info-circle me-2"),
                    html.Span([
                        "Esta vista muestra todos los códigos NFC asignados a las cerraduras. ",
                        "Los códigos se cargan automáticamente desde la API y pueden ser editados. ",
                        "Para editar un código, primero debe cargar la tabla y luego hacer clic en la celda correspondiente."
                    ])
                ], className="alert alert-info"),
                html.Div([
                    html.Strong(f"Dispositivos con NFC detectados: {devices_with_nfc}"),
                    html.Span(f" | Total de sensores NFC: {nfc_sensor_count}", className="ms-3"),
                ], className="mb-3 p-2 bg-light rounded border")
            ])
        ])
        
        # Añadir botón para refrescar datos NFC
        refresh_button = html.Div([
            dbc.Button([
                html.I(className="fas fa-sync-alt me-2"),
                "Actualizar Códigos NFC"
            ], id="nfc-refresh-button", color="primary", className="mb-3")
        ])
        
        # NUEVO: Añadir store para los datos de depuración
        debug_store = dcc.Store(id="nfc-debug-data-store", data={})
        
        # NUEVO: Añadir botón para mostrar/ocultar el panel de depuración
        debug_button = html.Div([
            dbc.Button([
                html.I(className="fas fa-bug me-2"),
                "Mostrar Panel de Depuración"
            ], id="nfc-debug-toggle-button", color="warning", className="mb-3 ms-2"),
            dbc.Collapse([
                html.Div(id="nfc-debug-panel", className="debug-panel mt-3 p-3 bg-light border rounded")
            ], id="nfc-debug-collapse", is_open=False)
        ])
        
        # Crear un contenedor con toda la información
        return html.Div([
            info_section,
            html.Div([
            refresh_button,
                debug_button
            ], className="d-flex"),
            nfc_grid,
            debug_store
        ], className="nfc-grid-view mt-4")
        
    # Callback para actualizar los datos NFC cuando se hace clic en el botón de refrescar
    @app.callback(
        Output("nfc-update-trigger", "data", allow_duplicate=True),
        [Input("nfc-refresh-button", "n_clicks")],
        [State("nfc-update-trigger", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return={"refreshed": False})
    def refresh_nfc_data(n_clicks, current_data):
        if not n_clicks:
            return dash.no_update
            
        # Incrementar el contador para forzar la actualización
        current_count = current_data.get("count", 0) if current_data else 0
        return {"updated": True, "count": current_count + 1, "refreshed": True}
    
    # Callback para mostrar u ocultar el filtro de tipo de cerradura
    @app.callback(
        Output("smart-locks-type-filter-container", "style"),
        [Input("smart-locks-data-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return={"display": "none"})
    def toggle_type_filter_visibility(devices_data):
        # Siempre ocultar el filtro de tipo, ya que ahora mostramos todos los códigos NFC
        return {"display": "none"}
    
    # Callback para cargar los tipos de cerradura en el filtro
    @app.callback(
        [Output("smart-locks-type-filter", "options"),
         Output("smart-locks-type-filter", "value"),
         Output("smart-locks-type-filter-info", "children")],
        [Input("smart-locks-data-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[[{"label": "Sin tipos disponibles", "value": ""}], None, ""])
    def load_lock_types(devices_data):
        if not devices_data or len(devices_data) == 0:
            return [], None, ""
        
        # Extraer los tipos únicos de cerradura
        device_types = {}  # Usamos un diccionario para contar dispositivos por tipo
        
        for device in devices_data:
            device_type = device.get("device_type", "UNKNOWN")
            device_types[device_type] = device_types.get(device_type, 0) + 1
        
        # Crear las opciones para el dropdown
        options = [{"label": f"{device_type} ({count})", "value": device_type} 
                  for device_type, count in sorted(device_types.items())]
        
        # Mostrar el número total de tipos
        info_text = f"Total: {len(device_types)} tipos de cerradura"
        
        # Devolver las opciones, seleccionar el primer tipo y el texto informativo
        return options, options[0]["value"] if options else None, info_text
    
    # Callback para mostrar la matriz por tipo cuando se selecciona la pestaña y un tipo
    @app.callback(
        [Output("lock-type-grid-table", "data", allow_duplicate=True),
         Output("lock-type-grid-loading-indicator", "children", allow_duplicate=True),
         Output("lock-type-grid-error-container", "children", allow_duplicate=True)],
        [Input("lock-type-grid-data-store", "data")],
        [State("lock-type-grid-table", "data"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[[], "", html.Div("Error al cargar datos de sensores", className="alert alert-danger")])
    def load_sensor_values_duplicate(grid_data, current_table_data, token_data):
        # Verificar que haya datos válidos
        if not grid_data or not grid_data.get("asset_ids") or not current_table_data:
            return current_table_data, "", ""
        
        # Verificar autenticación
        token = token_data.get('token') if token_data else None
        if not token:
            return current_table_data, "", html.Div([
                html.I(className="fas fa-exclamation-circle me-2"),
                "No se pudo autenticar para obtener datos de sensores."
            ], className="alert alert-warning")
        
        # Obtener los asset_ids únicos para consultar
        asset_ids = grid_data.get("asset_ids", [])
        if not asset_ids:
            return current_table_data, "", html.Div([
                html.I(className="fas fa-info-circle me-2"),
                "No se encontraron espacios (assets) para consultar valores de sensores."
            ], className="alert alert-info")
        
        # Iniciar proceso de carga de datos de sensores
        errors = []
        updated_data = current_table_data.copy()
        
        # Registrar inicio de proceso
        logger.info(f"Iniciando carga de valores de sensores para {len(asset_ids)} espacios y {len(updated_data)} cerraduras")
        
        # Crear un mapa de device_id a índice en la tabla para actualización eficiente
        device_to_index = {row["device_id"]: i for i, row in enumerate(updated_data)}
        
        # En este caso, solo vamos a actualizar valores básicos que ya tenemos
        # No necesitamos hacer llamadas a la API adicionales en esta fase
        
        # En una implementación real, aquí podrías hacer llamadas a la API para obtener los valores más recientes de los sensores.
        # Por ejemplo:
        # with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        #     future_to_asset = {executor.submit(fetch_sensor_values, asset_id, token): asset_id for asset_id in asset_ids}
        #     ... procesar resultados ...
        
        # Mensaje de éxito
        success_message = html.Div([
            html.I(className="fas fa-check-circle me-2", style={"color": "green"}),
            "Matriz por tipo cargada correctamente."
        ], className="alert alert-success")
        
        return updated_data, "", success_message

    # Callback para cargar datos NFC de la API en la tabla del grid
    @app.callback(
        [Output("nfc-grid-table", "data", allow_duplicate=True),
         Output("nfc-grid-table", "columns", allow_duplicate=True),
         Output("nfc-grid-loading-indicator", "children", allow_duplicate=True),
         Output("nfc-grid-error-container", "children", allow_duplicate=True)],
        [Input("nfc-grid-data-store", "data"),
         Input("nfc-update-trigger", "data")],
        [State("nfc-grid-table", "data"),
         State("nfc-grid-table", "columns"),
         State("jwt-token-store", "data"),
         State("nfc-grid-filter-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[[], [], "", html.Div("Error al cargar datos NFC", className="alert alert-danger")])
    def load_nfc_grid_data(grid_data, update_trigger, current_table_data, current_columns, token_data, filter_data):
        # Verificar que haya datos válidos
        if not grid_data or not current_table_data or not current_columns:
            return current_table_data, current_columns, "", ""
        
        # Verificar autenticación
        token = token_data.get('token') if token_data else None
        if not token:
            return current_table_data, current_columns, "", html.Div([
                html.I(className="fas fa-exclamation-circle me-2"),
                "No se pudo autenticar para obtener códigos NFC."
            ], className="alert alert-warning")

        # Importar la función para formatear valores NFC
        from components.smart_locks.nfc_grid.nfc_display_grid import format_nfc_value
        import re
        
        # Función auxiliar para formatear un valor NFC y marcar como procesado
        def process_nfc_value(value):
            if not value:
                return ""
                
            # Verificar si es un string
            if not isinstance(value, str):
                value = str(value)
                
            # Eliminar espacios
            value = value.strip()
            
            # Si después de strip es vacío
            if not value:
                return ""
                
            # Verificar si ya está formateado (comienza con el indicador)
            if value.startswith("➤"):
                return value
                
            # Formatear y devolver el valor procesado
            return format_nfc_value(value)
        
        # Obtener los asset_ids únicos para consultar
        asset_ids = grid_data.get("asset_ids", [])
        sensor_ids = grid_data.get("sensor_ids", [])
        if not asset_ids:
            return current_table_data, current_columns, "", html.Div([
                html.I(className="fas fa-info-circle me-2"),
                "No se encontraron espacios (assets) para consultar códigos NFC."
            ], className="alert alert-info")
        
        logger.info(f"Iniciando carga de códigos NFC para {len(asset_ids)} espacios y {len(sensor_ids)} sensores")
        
        # Iniciar proceso de carga
        loading_indicator = html.Div(f"Cargando códigos NFC para {len(asset_ids)} espacios...", className="text-info")
        
        # Hacer una copia de los datos actuales para no modificar el original
        updated_data = current_table_data.copy() if current_table_data else []
        updated_columns = current_columns.copy() if current_columns else []
        
        # NUEVO: Crear un diccionario para almacenar los valores de los sensores
        sensor_values_by_device = {}
        
        # NUEVO: Registrar los valores existentes en los datos
        for row in current_table_data:
            device_id = row.get("device_id", "")
            if not device_id:
                continue
                
            sensor_values_by_device[device_id] = {}
            
            for sensor_id in sensor_ids:
                cell_id = f"sensor_{sensor_id}"
                if cell_id in row:
                    value = row.get(cell_id, "")
                    # Si el valor no es N/A y no está vacío, registrarlo
                    if value and value != "N/A" and value != "No asignado":
                        sensor_values_by_device[device_id][sensor_id] = value
                        logger.info(f"Valor existente: dispositivo {device_id}, sensor {sensor_id}, valor '{value}'")
        
        # Crear un mapa columna_id -> índice para acceso rápido
        column_id_to_index = {col['id']: i for i, col in enumerate(updated_columns)}
        # Crear un mapa de device_id a índice en la tabla para actualización eficiente
        device_to_index = {row["device_id"]: i for i, row in enumerate(updated_data)}
        
        # Nuevos sensores encontrados (sensor_id -> info)
        new_sensors = {}
        
        # Crear un ThreadPoolExecutor para realizar múltiples solicitudes en paralelo
        import concurrent.futures
        import traceback
        from utils.api import fetch_nfc_passwords_for_asset
        
        # Contador para estadísticas
        nfc_sensors_found = 0
        total_nfc_codes = 0
        errors = []
        results = []
        
        # PASO 1: Obtener información NFC desde la API para todos los assets
        try:
            # Limitar el número de trabajadores a 5 para no sobrecargar la API
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                # Enviar todas las solicitudes en paralelo
                futures = [
                    executor.submit(fetch_nfc_passwords_for_asset, asset_id, token)
                    for asset_id in asset_ids
                ]
                
                # Esperar a que todas las solicitudes terminen
                for future in concurrent.futures.as_completed(futures):
                    try:
                        asset_id, data = future.result()
                        if data:
                            results.append((asset_id, data))
                        else:
                            logger.warning(f"No se obtuvieron datos NFC para asset_id: {asset_id}")
                    except Exception as e:
                        errors.append(str(e))
                        logger.error(f"Error al obtener datos NFC: {str(e)}")
        except Exception as e:
            errors.append(str(e))
            logger.error(f"Error al crear ThreadPoolExecutor: {str(e)}")
            
        # NUEVO: Almacenar datos raw de la API para el panel de depuración
        api_raw_data = {}
        for asset_id, data in results:
            api_raw_data[asset_id] = data
        
        # PASO 2: Procesar los resultados y actualizar la tabla
        # Mapa para almacenar todos los valores NFC por asset_id y sensor_id
        nfc_values_by_asset = {}
        
        # Si hay errores, registrarlos pero continuar con el procesamiento
        if errors:
            logger.error(f"Se encontraron {len(errors)} errores al obtener datos NFC: {errors}")
        
        # Procesamiento de los resultados
        for asset_id, data in results:
            try:
                # Convertir los datos a formato JSON si vienen como string
                import json
                if isinstance(data, str):
                    data = json.loads(data)
                
                # Convertir a formato esperado si es un diccionario directamente
                if isinstance(data, dict) and "data" in data:
                    data = data["data"]
                    logger.debug(f"Procesando data de tipo {type(data)} con {len(data) if isinstance(data, list) else 'N/A'} elementos")
                
                # Procesar según el formato de datos
                if isinstance(data, list):
                    # Inicializar el mapa para este asset
                    nfc_values_by_asset[asset_id] = {}
                    
                    # MEJORA: Loguear información detallada sobre los dispositivos encontrados
                    device_ids = [d.get("device_id", "unknown") for d in data if isinstance(d, dict)]
                    logger.info(f"Encontrados {len(data)} dispositivos para asset {asset_id}: {device_ids}")
                    
                    # Procesar cada elemento de datos (dispositivos)
                    for device in data:
                        try:
                            # Verificar que el ítem tenga la estructura esperada
                            if not isinstance(device, dict):
                                logger.error(f"Formato inesperado en datos NFC: {type(device)}")
                                continue
                
                            # Obtener el ID del dispositivo
                            device_id = device.get("device_id", "")
                            if not device_id:
                                logger.error("Dispositivo sin ID en datos NFC")
                                continue
                            
                            # MEJORA: Inicializar la estructura para este dispositivo si no existe
                            if device_id not in sensor_values_by_device:
                                sensor_values_by_device[device_id] = {}
                            
                            # Comprobar si el dispositivo está en la tabla antes de continuar procesando
                            in_grid = device_id in device_to_index
                            if not in_grid:
                                logger.warning(f"Dispositivo {device_id} no está en la matriz, sus valores NFC no se mostrarán")
                            
                            # MEJORA: Guardar toda la información de sensor_passwords para procesamiento posterior
                            all_sensor_passwords = []
                            
                            # CASO 1: Procesar la lista sensor_passwords si existe
                            if "sensor_passwords" in device and isinstance(device["sensor_passwords"], list):
                                sensor_pwds = device["sensor_passwords"]
                                logger.info(f"Procesando {len(sensor_pwds)} sensor_passwords para dispositivo {device_id}")
                                
                                # Procesar cada sensor_password
                                for sensor_pw in sensor_pwds:
                                    try:
                                        if not isinstance(sensor_pw, dict):
                                            continue
                                            
                                        # Extraer información del sensor
                                        sensor_id = str(sensor_pw.get("sensor_id", ""))
                                        password = sensor_pw.get("password", "")
                                        
                                        # Verificar datos necesarios
                                        if not sensor_id:
                                            logger.warning(f"Ignorando sensor_password sin sensor_id para dispositivo {device_id}")
                                            continue
                
                                        # MEJORA: Guardar para procesamiento uniforme posterior
                                        all_sensor_passwords.append({
                                            "sensor_id": sensor_id,
                                            "password": password,
                                            "name": sensor_pw.get("name", f"Sensor {sensor_id}"),
                                            "source": "sensor_passwords"
                                        })
                                    except Exception as e:
                                        logger.error(f"Error al procesar sensor_password: {str(e)}")
                            
                            # CASO 2: Procesar cada sensor individualmente (compatibilidad con estructura anterior)
                            sensor_id = str(device.get("sensor_id", ""))
                            password = device.get("password", "") or device.get("nfc_password", "") or device.get("nfc_code", "")
                            
                            # Si hay sensor y contraseña, procesarlo
                            if sensor_id and password:
                                all_sensor_passwords.append({
                                    "sensor_id": sensor_id,
                                    "password": password,
                                    "name": device.get("name", f"Sensor {sensor_id}"),
                                    "source": "device"
                                })
                            
                            # MEJORA: Ahora procesamos uniformemente todos los sensor_passwords recopilados
                            for sensor_data in all_sensor_passwords:
                                sensor_id = sensor_data["sensor_id"]
                                password = sensor_data["password"]
                                source = sensor_data["source"]
                                name = sensor_data["name"]
                                
                                # Si no hay contraseña, continuar con el siguiente
                                if not password:
                                    continue
                            
                                # CORRECCIÓN: Eliminar espacios en blanco antes de guardar
                                password = password.strip() if isinstance(password, str) else password
                                if not password:  # Verificar nuevamente después de strip() por si era solo espacios
                                    continue
                                
                                # MEJORA: Formatear el valor para hacerlo visualmente claro
                                formatted_password = process_nfc_value(password)
                                
                                logger.info(f"Valor NFC encontrado ({source}): dispositivo {device_id}, sensor {sensor_id}, valor '{formatted_password}' (original: '{password}')")
                                
                                # Guardar siempre en el diccionario para referencia
                                sensor_values_by_device[device_id][sensor_id] = formatted_password
                                logger.info(f"Valor NFC encontrado ({source}): dispositivo {device_id}, sensor {sensor_id}, valor '{formatted_password}'")
                                
                                # Procesar solo si el dispositivo está en la tabla
                                if in_grid:
                                    row_index = device_to_index[device_id]
                                            cell_id = f"sensor_{sensor_id}"
                            
                                    # MEJORA: Verificar si la columna ya existe en las columnas actuales
                                    column_exists = cell_id in column_id_to_index
                                    
                                    if not column_exists:
                                        # Si la columna no existe, guardarla para crearla después
                                                if sensor_id not in new_sensors:
                                            new_sensors[sensor_id] = {}
                                
                                        # Guardar toda la información necesaria para crear la columna
                                        new_sensors[sensor_id][device_id] = {
                                            "sensor_id": sensor_id,
                                            "name": name,
                                            "password": formatted_password,
                                            "sensor_type": "NFC_CODE",
                                            "is_nested_nfc": source == "sensor_passwords",
                                            "source": source
                                        }
                                        logger.debug(f"Registrando nuevo sensor {sensor_id} para crear columna posterior")
                                    else:
                                        # Si la columna existe, verificar si la celda existe en la fila
                                        if cell_id in updated_data[row_index]:
                                            # Actualizar el valor
                                            current_value = updated_data[row_index][cell_id]
                                            # CORRECCIÓN: Considerar valor actual como vacío si es solo espacios
                                            if current_value == "N/A" or not current_value or current_value.strip() == "":
                                                logger.info(f"Actualizando celda {cell_id} para dispositivo {device_id} con valor '{formatted_password}'")
                                                # CORRECCIÓN: Asegurar que el valor no sea un espacio
                                                updated_data[row_index][cell_id] = formatted_password
                                                nfc_sensors_found += 1
                                                total_nfc_codes += 1
                                            else:
                                                logger.debug(f"No se actualiza celda {cell_id} porque ya tiene valor: '{current_value}'")
                        except Exception as e:
                            logger.error(f"Error al procesar dispositivo NFC: {str(e)}")
                            logger.error(traceback.format_exc())
                elif isinstance(data, dict):
                    # CASO 3: Extraer valores de formato alternativo (sin procesar por fetch_nfc_passwords_for_asset)
                    for sensor_id, password_info in data.items():
                        try:
                            if isinstance(password_info, dict):
                                # Formato: {sensor_id: {device_id: password, ...}, ...}
                                for device_id, password in password_info.items():
                                    if device_id and password:
                                        # CORRECCIÓN: Eliminar espacios en blanco antes de guardar
                                        password = password.strip() if isinstance(password, str) else password
                                        if not password:  # Verificar nuevamente después de strip() por si era solo espacios
                                            continue
                                        
                                        # MEJORA: Formatear el valor para hacerlo visualmente claro
                                        formatted_password = process_nfc_value(password)
                                        
                                        logger.info(f"Valor NFC formato alternativo 1: sensor {sensor_id}, dispositivo {device_id}, valor '{formatted_password}' (original: '{password}')")
                                        
                                        # Guardar en diccionario temporal
                                        if device_id not in sensor_values_by_device:
                                            sensor_values_by_device[device_id] = {}
                                        sensor_values_by_device[device_id][sensor_id] = formatted_password
                                        
                                        # Actualizar la tabla si el dispositivo existe
                                        if device_id in device_to_index:
                                            row_index = device_to_index[device_id]
                                                    cell_id = f"sensor_{sensor_id}"
                                            
                                            # Verificar si la celda existe en las columnas actuales
                                            if cell_id not in column_id_to_index:
                                                # Si no existe, guardarla para crearla después
                                                        if sensor_id not in new_sensors:
                                                    new_sensors[sensor_id] = {}
                                                
                                                # Guardar información para crear la columna
                                                new_sensors[sensor_id][device_id] = {
                                                    "sensor_id": sensor_id,
                                                    "name": f"Sensor {sensor_id}",
                                                    "password": formatted_password,
                                                    "sensor_type": "NFC_CODE",
                                                    "source": "alt_format_1"
                                                }
                                            else:
                                                # Si la columna existe, actualizar el valor
                                            if cell_id in updated_data[row_index]:
                                                    current_value = updated_data[row_index][cell_id]
                                                    # CORRECCIÓN: Considerar valor actual como vacío si es solo espacios
                                                    if current_value == "N/A" or not current_value or current_value.strip() == "":
                                                        logger.info(f"Actualizando celda {cell_id} para dispositivo {device_id} con valor '{formatted_password}'")
                                                        updated_data[row_index][cell_id] = formatted_password
                                                nfc_sensors_found += 1
                                                total_nfc_codes += 1
                            elif isinstance(password_info, str) and sensor_id.isdigit():
                                # Formato: {sensor_id: password, ...}
                                # Aquí no tenemos device_id, así que intentamos asignarlo a todos los dispositivos relevantes
                                password = password_info
                                
                                # CORRECCIÓN: Eliminar espacios en blanco antes de guardar
                                password = password.strip() if isinstance(password, str) else password
                                if not password:  # Verificar nuevamente después de strip() por si era solo espacios
                                    continue
                                    
                                # MEJORA: Formatear el valor para hacerlo visualmente claro
                                formatted_password = process_nfc_value(password)
                                    
                                logger.info(f"Valor NFC formato alternativo 2: sensor {sensor_id}, valor '{formatted_password}' (original: '{password}')")
                                
                                # Intentar buscar en qué dispositivos aparece este sensor
                                assigned = False
                                for device_id, device_row_index in device_to_index.items():
                                            cell_id = f"sensor_{sensor_id}"
                                    
                                    # Verificar si la celda existe en las columnas actuales
                                    if cell_id not in column_id_to_index:
                                        # Si no existe, guardarla para crearla después
                                                if sensor_id not in new_sensors:
                                            new_sensors[sensor_id] = {}
                                        
                                        # Guardar información para crear la columna
                                        if device_id not in new_sensors[sensor_id]:
                                            new_sensors[sensor_id][device_id] = {
                                                "sensor_id": sensor_id,
                                                "name": f"Sensor {sensor_id}",
                                                "password": formatted_password,
                                                "sensor_type": "NFC_CODE",
                                                "source": "alt_format_2"
                                            }
                                            
                                            # Guardar en diccionario temporal
                                            if device_id not in sensor_values_by_device:
                                                sensor_values_by_device[device_id] = {}
                                            sensor_values_by_device[device_id][sensor_id] = formatted_password
                                    else:
                                    # Si la celda existe y es N/A o está vacía, actualizar
                                    if cell_id in updated_data[device_row_index]:
                                        current_value = updated_data[device_row_index][cell_id]
                                            # CORRECCIÓN: Considerar valor actual como vacío si es solo espacios
                                            if current_value == "N/A" or not current_value or current_value.strip() == "":
                                                updated_data[device_row_index][cell_id] = formatted_password
                                                assigned = True
                                            nfc_sensors_found += 1
                                            total_nfc_codes += 1
                                                logger.info(f"Asignando valor '{formatted_password}' a sensor {sensor_id} del dispositivo {device_id}")
                                                
                                                # Guardar en diccionario temporal
                                                if device_id not in sensor_values_by_device:
                                                    sensor_values_by_device[device_id] = {}
                                                sensor_values_by_device[device_id][sensor_id] = formatted_password
                        except Exception as e:
                            logger.error(f"Error al procesar formato alternativo: {str(e)}")
                else:
                    logger.error(f"Formato de datos NFC inesperado: {type(data)}")
            except Exception as e:
                logger.error(f"Error al procesar resultados NFC para asset {asset_id}: {str(e)}")
                logger.error(traceback.format_exc())
        
        # PASO 3: Verificación y recuperación de valores
        
        # MEJORA: Log detallado de los valores encontrados
        logger.info(f"Valores NFC recopilados para {len(sensor_values_by_device)} dispositivos")
        for device_id, sensors in sensor_values_by_device.items():
            if sensors:
                sensor_list = [f"{s_id}='{value}'" for s_id, value in sensors.items()]
                logger.info(f"Dispositivo {device_id}: {len(sensors)} valores - {', '.join(sensor_list)}")
        
        # MEJORA: Enfoque más agresivo para recuperar valores importantes
        important_sensors = ["2", "8", "9", "10"]
        logger.info(f"Verificando específicamente sensores importantes: {important_sensors}")
        
        # Intentar asignar valores a todas las celdas posibles
        for device_id, sensors in sensor_values_by_device.items():
            if device_id in device_to_index:
                row_index = device_to_index[device_id]
                
                # Primero asignar todos los valores disponibles
                for sensor_id, value in sensors.items():
                    # CORRECCIÓN: Asegurar que el valor no sea solo espacios
                    if isinstance(value, str):
                        raw_value = value
                        value = value.strip()
                        if not value:  # Si después de strip() está vacío, continuar
                            continue
                                
                        # MEJORA: Formatear el valor para hacerlo visualmente claro
                        value = process_nfc_value(raw_value)
                    
                    cell_id = f"sensor_{sensor_id}"
                    
                    # Si la celda existe en los datos actuales, asignar el valor
                    if cell_id in updated_data[row_index]:
                        current_value = updated_data[row_index][cell_id]
                        # CORRECCIÓN: Considerar valor actual como vacío si es solo espacios
                        if current_value == "N/A" or not current_value or (isinstance(current_value, str) and current_value.strip() == ""):
                            logger.info(f"RECUPERACIÓN GENERAL: Asignando valor '{value}' a celda {cell_id} del dispositivo {device_id}")
                            updated_data[row_index][cell_id] = value
                            total_nfc_codes += 1
                
                # Luego verificar específicamente los sensores importantes
                for sensor_id in important_sensors:
                    if sensor_id in sensors:
                        value = sensors[sensor_id]
                        # CORRECCIÓN: Asegurar que el valor no sea solo espacios
                        if isinstance(value, str):
                            raw_value = value
                            value = value.strip()
                            if not value:  # Si después de strip() está vacío, continuar
                                continue
                                
                            # MEJORA: Formatear el valor para hacerlo visualmente claro
                            value = process_nfc_value(raw_value)
                        
                    cell_id = f"sensor_{sensor_id}"
                    
                        # MEJORA: Si la columna no existe, asegurarse de que se cree
                        if cell_id not in column_id_to_index:
                            if sensor_id not in new_sensors:
                                new_sensors[sensor_id] = {}
                            
                            # Guardar información para crear la columna
                            if device_id not in new_sensors[sensor_id]:
                                new_sensors[sensor_id][device_id] = {
                                    "sensor_id": sensor_id,
                                    "name": f"Sensor Importante {sensor_id}",
                                    "password": value,
                                    "sensor_type": "NFC_CODE",
                                    "source": "important_sensor",
                                    "is_important": True
                                }
                                logger.info(f"Registrando sensor importante {sensor_id} para crear columna posterior")
                        else:
                            # Si la columna existe, verificar la celda
                        if cell_id in updated_data[row_index]:
                            current_value = updated_data[row_index][cell_id]
                                # CORRECCIÓN: Considerar valor actual como vacío si es solo espacios
                                if current_value == "N/A" or not current_value or (isinstance(current_value, str) and current_value.strip() == ""):
                                logger.info(f"RECUPERACIÓN SENSOR IMPORTANTE: Asignando valor '{value}' a sensor {sensor_id} del dispositivo {device_id}")
                                updated_data[row_index][cell_id] = value
                                total_nfc_codes += 1
        
        # PASO 4: Actualizar las columnas
        
        # Extraer columnas base (device_id, lock_name, asset_name)
        base_columns = [col for col in updated_columns if not col["id"].startswith("sensor_")]
        
        # Extraer columnas de sensores existentes
        sensor_columns = [col for col in updated_columns if col["id"].startswith("sensor_")]
        
        # MEJORA: Registrar todas las columnas de sensores existentes
        existing_sensor_ids = [col["id"].replace("sensor_", "") for col in sensor_columns]
        sensor_columns_log = ", ".join([f"{col['id']}='{col['name']}'" for col in sensor_columns])
        logger.info(f"Columnas de sensores existentes: {existing_sensor_ids}")
        logger.debug(f"Detalle de columnas de sensores: {sensor_columns_log}")
        
        # MEJORA: Primero asegurarse de que los sensores importantes tienen columnas
        for important_id in important_sensors:
            # Si el sensor importante ya tiene columna, continuar
            if f"sensor_{important_id}" in [col["id"] for col in sensor_columns]:
                continue
                
            # Si no tiene columna pero hay datos, crear la columna
            has_data = False
            for device_sensors in sensor_values_by_device.values():
                if important_id in device_sensors:
                    has_data = True
                    break
            
            if has_data or important_id in new_sensors:
                # Crear columna para este sensor importante
                sensor_columns.append({
                    "name": f"🔑 Sensor Importante {important_id}",
                    "id": f"sensor_{important_id}"
                })
                logger.info(f"Creada columna para sensor importante {important_id}")
        
        # MEJORA: Crear columnas para todos los sensores nuevos con valores
        for sensor_id, devices in new_sensors.items():
            # Verificar si ya existe una columna para este sensor
            if f"sensor_{sensor_id}" in [col["id"] for col in sensor_columns]:
                continue
                
            # Extraer un nombre de columna apropiado
            column_name = f"Sensor {sensor_id}"
            sensor_type = "NFC_CODE"
            is_important = False
            
            # Buscar información adicional en los dispositivos con valores
            devices_with_values = [d for d, item in devices.items() if item.get("password", "")]
            if devices_with_values:
                first_device_id = devices_with_values[0]
                item = devices[first_device_id]
                
                name = item.get("name", f"Sensor {sensor_id}")
                if name:
                    column_name = name
                
                # Verificar si es un sensor importante
                is_important = item.get("is_important", False) or sensor_id in important_sensors
                
                # Verificar si es de sensor_passwords
                if item.get("is_nested_nfc", False):
                    column_name = f"🔑 {column_name}"
                
            # Marcar visualmente los sensores importantes
            if is_important:
                column_name = f"🔑 {column_name.replace('🔑 ', '')}"
            
            # Crear y añadir la columna
            sensor_columns.append({
                "name": column_name,
                "id": f"sensor_{sensor_id}"
            })
            logger.info(f"Creada columna para sensor {sensor_id}: {column_name}")
        
        # MEJORA: Ordenar las columnas de sensores por el número del sensor
        sensor_columns.sort(key=lambda col: int(col["id"].replace("sensor_", "")) if col["id"].replace("sensor_", "").isdigit() else 999)
        
        # MEJORA: Aplicar el filtro de forma más inteligente
        if filter_data and "show_all" in filter_data:
            show_all = filter_data["show_all"]
            if not show_all:
                    # Detectar sensores con valores asignados
                    sensors_with_values = set()
                    
                # MEJORA: Agregar automáticamente los sensores importantes
                    for sensor_id in important_sensors:
                        sensors_with_values.add(sensor_id)
                        logger.info(f"Sensor importante {sensor_id} incluido forzosamente en filtro")
                    
                # Detectar sensores que realmente tienen valores
                    for row in updated_data:
                        for col in sensor_columns:
                            cell_id = col["id"]
                            if cell_id in row:
                                value = str(row[cell_id]).strip()
                            # Verificar si el valor es significativo
                            if value and value not in ["N/A", "No asignado", "No Asignado"]:
                                    sensor_id = cell_id.replace("sensor_", "")
                                    sensors_with_values.add(sensor_id)
                                    logger.debug(f"Detectado sensor {sensor_id} con valor: '{value}'")
                                
                    logger.info(f"Sensores con valores detectados: {sorted(list(sensors_with_values))}")
                    
                        # Filtrar columnas que tienen valores
                if sensors_with_values:
                        filtered_columns = [col for col in sensor_columns if col["id"].replace("sensor_", "") in sensors_with_values]
                        updated_columns = base_columns + filtered_columns
                    logger.info(f"Filtro aplicado: mostrando {len(filtered_columns)} de {len(sensor_columns)} columnas de sensores")
                    else:
                        updated_columns = base_columns + sensor_columns
                        logger.warning("No se detectaron sensores con valores. Se muestran todos.")
            else:
                # Mostrar todas las columnas
                updated_columns = base_columns + sensor_columns
                logger.info(f"Mostrando todas las columnas: {len(updated_columns)}")
        else:
            # Si no hay filtro, mostrar todas las columnas
            updated_columns = base_columns + sensor_columns
            logger.info(f"Sin filtro: mostrando todas las columnas ({len(updated_columns)})")
        
        # NUEVA SECCIÓN: Añadir valores de los nuevos sensores que faltan en las celdas
        for device_id, sensors in sensor_values_by_device.items():
            if device_id in device_to_index:
                row_index = device_to_index[device_id]
                
                # Revisar todos los sensores para este dispositivo
                for sensor_id, sensor_value in sensors.items():
                    cell_id = f"sensor_{sensor_id}"
                    
                    # Comprobar si este ID de celda ya existe en las columnas
                    cell_column_exists = False
                    for col in updated_columns:
                        if col["id"] == cell_id:
                            cell_column_exists = True
                            break
                    
                    # Si la columna existe pero la celda no tiene el valor asignado, asignarlo ahora
                    if cell_column_exists:
                        # Asegurarse de que la celda exista en la fila
                        if cell_id not in updated_data[row_index]:
                            updated_data[row_index][cell_id] = ""
                        
                        # Si la celda está vacía o tiene N/A, asignar el valor
                        current_value = updated_data[row_index][cell_id]
                        if current_value == "N/A" or not current_value or current_value.strip() == "":
                            updated_data[row_index][cell_id] = sensor_value
                            logger.info(f"Asignando valor faltante '{sensor_value}' a celda {cell_id} del dispositivo {device_id}")
                            total_nfc_codes += 1
                        
        # PASO 5: Mensaje final y última verificación de datos
        success_message = None
        if total_nfc_codes > 0:
            success_message = html.Div([
                html.I(className="fas fa-check-circle me-2"),
                f"Se cargaron {total_nfc_codes} códigos NFC para {nfc_sensors_found} sensores."
            ], className="alert alert-success")
        else:
            success_message = html.Div([
                html.I(className="fas fa-info-circle me-2"),
                "No se encontraron códigos NFC para mostrar."
            ], className="alert alert-info")
            
        # NUEVO: Actualizar store con información de debug
        # Actualizar grid_data con información recopilada para debug
        grid_data["from_api"] = api_raw_data
        grid_data["sensor_values_by_device"] = sensor_values_by_device
        grid_data["table_data"] = updated_data
        
        # Actualizar también el store con los nuevos datos
        nfc_grid_data_store = grid_data
        
        # CORRECCIÓN FINAL: Verificación para eliminar espacios en blanco de cualquier celda
        cleaned_rows = 0
        cleaned_cells = 0
        for i, row in enumerate(updated_data):
            for key, value in row.items():
                if isinstance(value, str) and value.strip() == "":
                    # Si el valor es solo espacios, cambiarlo a "N/A"
                    row[key] = "N/A"
                    cleaned_cells += 1
                    cleaned_rows += 1
                    logger.debug(f"CORRECCIÓN FINAL: Celda {key} en fila {i} limpiada - contenía solo espacios")
                    
                # Procesado adicional para asegurar visibilidad de valores
                elif isinstance(value, str) and key.startswith("sensor_") and value != "N/A" and not value.startswith("➤") and not value.startswith("[HEX:"):
                    # Si es un valor de sensor pero no está procesado, formatearlo
                    processed_value = process_nfc_value(value)
                    if processed_value != value:
                        row[key] = processed_value
                        logger.debug(f"FORMATEO FINAL: Celda {key} en fila {i} formateada - valor: '{value}' -> '{processed_value}'")

        # COMPROBACIÓN ADICIONAL: Verificar que los sensores con valores en logs realmente tienen valores asignados
        for device_id, sensors in sensor_values_by_device.items():
            if device_id in device_to_index:
                row_index = device_to_index[device_id]
                for sensor_id, value in sensors.items():
                    cell_id = f"sensor_{sensor_id}"
                    # Comprobar si esta celda existe en la fila y tiene el valor correcto
                    if cell_id in updated_data[row_index]:
                        row_value = updated_data[row_index][cell_id]
                        if row_value != value:
                            logger.warning(f"DISCREPANCIA: La celda {cell_id} para el dispositivo {device_id} tiene valor '{row_value}' pero debería ser '{value}'")
                            # Corregir el valor
                            updated_data[row_index][cell_id] = value
                            logger.info(f"CORRECCIÓN DE DISCREPANCIA: Asignado valor '{value}' a celda {cell_id} del dispositivo {device_id}")

        if cleaned_cells > 0:
            logger.info(f"CORRECCIÓN FINAL: Se limpiaron {cleaned_cells} celdas con espacios en blanco en {cleaned_rows} filas")
        
        return updated_data, updated_columns, "", success_message

    # Callback para manejar el toggle de mostrar todos los sensores o solo los que tienen valores
    @app.callback(
        [Output("nfc-grid-filter-store", "data"),
         Output("nfc-grid-table", "columns", allow_duplicate=True)],
        [Input("nfc-grid-filter-toggle", "value")],
        [State("nfc-grid-filter-store", "data"),
         State("nfc-grid-data-store", "data"),
         State("nfc-grid-table", "data"),
         State("nfc-grid-table", "columns")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[{"show_all": False}, []])
    def update_nfc_filter_toggle(show_all, current_filter_data, grid_data, table_data, current_columns):
        """
        Callback que actualiza las columnas visibles según el filtro seleccionado.
        Esta versión corregida asegura que el toggle "Mostrar todos los sensores" funcione correctamente.
        
        Args:
            show_all: Booleano que indica si mostrar todos los sensores
            current_filter_data: Datos actuales del filtro
            grid_data: Datos de la cuadrícula
            table_data: Datos de la tabla
            current_columns: Columnas actuales
        
        Returns:
            Tupla con datos del filtro actualizados y columnas a mostrar
        """
        import re
        
        if grid_data is None or not table_data:
            return {"show_all": show_all}, []
        
        # Agregar logs para diagnóstico
        logger.debug(f"Toggle valor: {show_all}")
        
        # Columnas base (siempre visibles)
        columns_base = [
            {"name": "ID", "id": "device_id"},
            {"name": "Cerradura", "id": "lock_name"},
            {"name": "Espacio", "id": "asset_name"},
        ]
        
        # Obtener todas las columnas de sensores existentes
        sensor_columns = [col for col in current_columns if col["id"].startswith("sensor_")]
        sensor_ids = [col["id"].replace("sensor_", "") for col in sensor_columns]
        logger.debug(f"Total de columnas de sensores existentes: {len(sensor_columns)} - IDs: {sensor_ids}")
        
        # Lista de sensores importantes que siempre deben mostrarse
        important_sensors = ["2", "8", "9", "10"]
        logger.debug(f"Sensores importantes que se incluirán forzosamente: {important_sensors}")
        
        if show_all:
            # CORRECCIÓN: Si el toggle está activado, mostrar REALMENTE todas las columnas
            display_columns = columns_base + sensor_columns
            logger.debug(f"Mostrando TODAS las columnas: {len(display_columns)} (base: {len(columns_base)}, sensores: {len(sensor_columns)})")
        else:
            # Si el toggle está desactivado, mostrar solo los sensores con valores o importantes
        sensors_with_values = set()
        
        # Agregar automáticamente los sensores importantes
        for sensor_id in important_sensors:
            sensors_with_values.add(sensor_id)
            logger.debug(f"Sensor importante {sensor_id} añadido forzosamente a sensores_with_values")
        
            # Detectar sensores con valores reales
            for row in table_data:
                for col in sensor_columns:
                    cell_id = col["id"]
                    if cell_id in row:
                        value = str(row[cell_id]).strip() if isinstance(row[cell_id], str) else row[cell_id]
                        # Verificar si el valor es significativo
                        if value and value not in ["N/A", "No asignado", "No Asignado"]:
                            sensor_id = cell_id.replace("sensor_", "")
                            sensors_with_values.add(sensor_id)
                            logger.debug(f"Detectado sensor {sensor_id} con valor: '{value}'")
                            
                        # Verificar específicamente formatos como MAC addresses
                        if isinstance(value, str) and (":" in value or "-" in value or "." in value):
                            sensor_id = cell_id.replace("sensor_", "")
                            sensors_with_values.add(sensor_id)
                            logger.debug(f"Detectado sensor {sensor_id} con formato especial: '{value}'")
                            
                        # Verificar formato hexadecimal
                        if isinstance(value, str) and re.match(r'^[0-9A-F]{8}$', value, re.IGNORECASE):
                            sensor_id = cell_id.replace("sensor_", "")
                            sensors_with_values.add(sensor_id)
                            logger.debug(f"Detectado sensor {sensor_id} con formato hexadecimal: '{value}'")
            
            logger.debug(f"Sensores con valores detectados: {len(sensors_with_values)} de {len(sensor_ids)}")
            
            # Filtrar columnas que tienen valores
            filtered_columns = [col for col in sensor_columns if col["id"].replace("sensor_", "") in sensors_with_values]
            display_columns = columns_base + filtered_columns
            logger.debug(f"Mostrando columnas filtradas: {len(display_columns)} (base: {len(columns_base)}, sensores: {len(filtered_columns)})")
        
        return {"show_all": show_all}, display_columns

    # NUEVO: Callback para activar la recopilación de datos de depuración cuando se carga la tabla
    @app.callback(
        Output("nfc-debug-data-store", "data"),
        [Input("nfc-grid-table", "data"),
         Input("nfc-grid-table", "columns")],
        [State("nfc-debug-data-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return={})
    def collect_debug_data(table_data, columns, current_debug_data):
        """
        Recopila información de depuración sobre los datos de la tabla NFC
        para identificar discrepancias entre los valores detectados y mostrados.
        """
        if not table_data or not columns:
            return {}
        
        # Extraer información relevante
        sensor_columns = [col for col in columns if col["id"].startswith("sensor_")]
        sensor_ids = [col["id"].replace("sensor_", "") for col in sensor_columns]
        
        # Contar valores por sensor
        sensor_values_count = {sensor_id: 0 for sensor_id in sensor_ids}
        all_values = {}
        
        # Analizar cada fila para contar valores
        for row in table_data:
            device_id = row.get("device_id", "")
            if not device_id:
                    continue
                    
            device_values = {}
            
            for sensor_id in sensor_ids:
                cell_id = f"sensor_{sensor_id}"
                if cell_id in row:
                    value = row.get(cell_id, "")
                    # Verificar si hay un valor real (no vacío y no N/A)
                    if value and value != "N/A" and (
                        not isinstance(value, str) or 
                        (isinstance(value, str) and value.strip() != "")
                    ):
                        sensor_values_count[sensor_id] += 1
                        device_values[sensor_id] = value
            
            if device_values:
                all_values[device_id] = device_values
        
        # Crear un resumen de la información
        debug_info = {
            "table_rows": len(table_data),
            "sensor_columns": [{"id": col["id"], "name": col["name"]} for col in sensor_columns],
            "sensor_values_count": sensor_values_count,
            "total_values_shown": sum(sensor_values_count.values()),
            "devices_with_values": len(all_values),
            "all_values": all_values,
            "timestamp": int(time.time())
        }
        
        return debug_info

    # NUEVO: Callback para mostrar/ocultar el panel de depuración
    @app.callback(
        [Output("nfc-debug-collapse", "is_open"),
         Output("nfc-debug-panel", "children")],
        [Input("nfc-debug-toggle-button", "n_clicks")],
        [State("nfc-debug-collapse", "is_open"),
         State("nfc-debug-data-store", "data"),
         State("nfc-grid-data-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[False, ""])
    def toggle_debug_panel(n_clicks, is_open, debug_data, grid_data):
        if not n_clicks:
            return is_open, dash.no_update
        
        # Si no hay datos de depuración, no mostrar nada
        if not debug_data:
            return not is_open, html.Div("No hay datos de depuración disponibles", className="text-danger")
        
        # Crear el panel de depuración
        sensor_data_table = []
        if "sensor_values_count" in debug_data:
            for sensor_id, count in debug_data["sensor_values_count"].items():
                sensor_data_table.append(html.Tr([
                    html.Td(f"Sensor {sensor_id}"),
                    html.Td(count),
                    html.Td(f"sensor_{sensor_id}")
                ]))
        
        # Asset IDs de grid_data
        asset_ids = grid_data.get("asset_ids", []) if grid_data else []
        
        # Extraer todos los dispositivos y valores de la tabla
        all_devices = {}
        device_values = {}
        
        if "all_values" in debug_data:
            device_values = debug_data["all_values"]
            
        # Obtener toda la información de la tabla
        table_data = grid_data.get("table_data", []) if grid_data else []
        
        # Intentar organizar dispositivos por asset_id
        devices_by_asset = {}
        for row in table_data:
            device_id = row.get("device_id", "")
            asset_name = row.get("asset_name", "Desconocido")
            if not device_id:
                continue
                
            # Intentar determinar el asset_id de este dispositivo
            # Primero miramos la estructura devices_by_asset
            asset_id_found = None
            for asset_id in asset_ids:
                if asset_id not in devices_by_asset:
                    devices_by_asset[asset_id] = []
                
                # Si el nombre del asset contiene el ID, asumimos que pertenece a este asset
                if asset_name and str(asset_id) in str(asset_name):
                    asset_id_found = asset_id
                    break
            
            # Si no encontramos el asset_id, asignarlo al primer asset como fallback
            if not asset_id_found and asset_ids:
                asset_id_found = asset_ids[0]
                
            # Guardar el dispositivo en el asset correspondiente
            if asset_id_found:
                # Crear un diccionario con la información del dispositivo
                device_info = {
                    "device_id": device_id,
                    "asset_name": asset_name,
                    "lock_name": row.get("lock_name", "Sin nombre"),
                    "has_values": device_id in device_values,
                    "values": device_values.get(device_id, {})
                }
                devices_by_asset[asset_id_found].append(device_info)
        
        # MEJORA: Obtener información de devices_by_asset desde otras fuentes
        # Intentar obtener más datos del estado de sensor_values_by_device que se usa en load_nfc_grid_data
        from_api_data = grid_data.get("from_api", {}) if grid_data else {}
        
        # Crear la vista jerárquica de assets, dispositivos y valores
        hierarchy_view = []
        
        # Para cada asset, mostrar los dispositivos y sus valores
        for asset_id in asset_ids:
            devices = devices_by_asset.get(asset_id, [])
            
            # Crear lista de dispositivos para este asset
            devices_list = []
            for device in devices:
                device_id = device["device_id"]
                values = device["values"]
                
                # Crear lista de valores para este dispositivo
                values_list = []
                for sensor_id, value in values.items():
                    values_list.append(html.Li([
                        html.Strong(f"Sensor {sensor_id}: "),
                        html.Span(f"{value}")
                    ]))
                
                # Crear elemento para este dispositivo
                device_item = html.Li([
                    html.Div([
                        html.Strong(f"Dispositivo: {device_id} "),
                        html.Span(f"({device['lock_name']})", className="text-muted")
                    ]),
                    html.Div([
                        html.Ul(values_list) if values_list else html.P("No hay valores NFC", className="text-warning ms-3")
                    ], className="ms-3")
                ], className="mt-2")
                
                devices_list.append(device_item)
            
            # Crear elemento para este asset
            asset_item = html.Div([
                html.Div([
                    html.Strong(f"Asset ID: {asset_id}"),
                ], className="p-2 bg-light border rounded"),
                html.Div([
                    html.Ul(devices_list) if devices_list else html.P("No hay dispositivos", className="text-warning")
                ], className="ms-3 mt-2")
            ], className="mb-3")
            
            hierarchy_view.append(asset_item)
        
        # NUEVO: Panel mejorado para debugging avanzado
        query_info = []
        for asset_id in asset_ids:
            # Datos de consulta API para este asset
            asset_api_info = []
            
            # Datos desde el ThreadPool (fetch_nfc_passwords_for_asset)
            if from_api_data and asset_id in from_api_data:
                api_data = from_api_data[asset_id]
                
                # Extraer dispositivos y sus sensores
                if isinstance(api_data, dict):
                    devices_info = []
                    # Si es una respuesta directa de API, puede tener formato diferente
                    if "data" in api_data and isinstance(api_data["data"], list):
                        for device in api_data["data"]:
                            if not isinstance(device, dict):
                                continue
                                
                            device_id = device.get("device_id", "")
                            if not device_id:
                                continue
                                
                            # Extraer sensores NFC
                            sensor_passwords = device.get("sensor_passwords", [])
                            sensor_info = []
                            
                            for sensor in sensor_passwords:
                                if not isinstance(sensor, dict):
                                    continue
                                    
                                sensor_id = sensor.get("sensor_id", "")
                                password = sensor.get("password", "")
                                
                                sensor_info.append(html.Li([
                                    html.Strong(f"Sensor {sensor_id}: "),
                                    html.Span(f"{password}")
                                ]))
                            
                            devices_info.append(html.Li([
                                html.Strong(f"Dispositivo {device_id}: "),
                                html.Ul(sensor_info) if sensor_info else html.Span("No hay sensores NFC")
                            ]))
                    
                    asset_api_info.append(html.Div([
                        html.H6(f"Datos API para Asset {asset_id}:"),
                        html.Ul(devices_info) if devices_info else html.P("No hay dispositivos")
                    ]))
            
            query_info.append(html.Div([
                html.Div([
                    html.Strong(f"Consulta para Asset ID: {asset_id}"),
                ], className="p-2 bg-light border rounded"),
                html.Div(asset_api_info, className="ms-3 mt-2")
            ], className="mb-3"))
        
        # Crear el panel completo
        panel_content = html.Div([
            html.H5("Panel de Depuración NFC", className="mb-3"),
            
            # Resumen de datos
            html.Div([
                html.H6("Resumen de Datos", className="mb-2"),
                html.Ul([
                    html.Li(f"Filas en la tabla: {debug_data.get('table_rows', 0)}"),
                    html.Li(f"Columnas de sensores: {len(debug_data.get('sensor_columns', []))}"),
                    html.Li(f"Total de valores mostrados: {debug_data.get('total_values_shown', 0)}"),
                    html.Li(f"Dispositivos con valores: {debug_data.get('devices_with_values', 0)}"),
                    html.Li(f"Assets consultados: {len(asset_ids)}")
                ])
            ], className="mb-4"),
            
            # Nueva sección jerárquica de Assets, Dispositivos y Valores
            html.Div([
                html.H6("Jerarquía Assets > Dispositivos > Valores", className="mb-2"),
                html.Div(
                    # Usar children en lugar de desempaquetado
                    children=hierarchy_view if hierarchy_view else [html.P("No hay datos para mostrar")],
                    style={"maxHeight": "400px", "overflowY": "auto"}, 
                    className="debug-content-container p-3"
                )
            ], className="mb-4"),
            
            # Mostrar detalles de consulta API por Asset
            html.Div([
                html.H6("Información de Consultas API", className="mb-2"),
                html.Div([
                    html.P("Esta sección muestra los datos obtenidos directamente de la API")
                ] + (query_info if query_info else [html.P("No hay datos de consulta disponibles")]),
                style={"maxHeight": "400px", "overflowY": "auto"}, 
                className="debug-content-container p-3")
            ], className="mb-4"),
            
            # Valores por sensor (tabla)
            html.Div([
                html.H6("Valores por Sensor", className="mb-2"),
                html.Div([
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("Sensor"),
                                html.Th("Valores"),
                                html.Th("ID Columna")
                            ])
                        ]),
                        html.Tbody(sensor_data_table)
                    ], className="table table-sm table-bordered")
                ], style={"maxHeight": "200px", "overflowY": "auto"}, className="debug-table-container")
            ], className="mb-4"),
            
            # Columnas detectadas
            html.Div([
                html.H6("Columnas de Sensores", className="mb-2"),
                html.Div([
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("ID"),
                                html.Th("Nombre")
                            ])
                        ]),
                        html.Tbody([
                            html.Tr([
                                html.Td(col["id"]),
                                html.Td(col["name"])
                            ]) for col in debug_data.get("sensor_columns", [])
                        ])
                    ], className="table table-sm table-bordered")
                ], style={"maxHeight": "200px", "overflowY": "auto"}, className="debug-table-container")
            ], className="mb-4")
        ])
        
        return not is_open, panel_content

    # NUEVO: Modificar también el CSS para el panel de depuración
    app.clientside_callback(
        """
        function(n_clicks) {
            if (n_clicks > 0) {
                // Estilos para el panel de depuración
                const styleEl = document.createElement('style');
                styleEl.textContent = `
                    .debug-panel {
                        font-family: monospace;
                        font-size: 0.9rem;
                    }
                    .debug-table-container {
                        border: 1px solid #ddd;
                        border-radius: 4px;
                    }
                    .debug-content-container {
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        padding: 10px;
                    }
                `;
                document.head.appendChild(styleEl);
            }
            return window.dash_clientside.no_update;
        }
        """,
        Output("nfc-debug-toggle-button", "n_clicks", allow_duplicate=True),
        [Input("nfc-debug-toggle-button", "n_clicks")],
        prevent_initial_call=True
    )

    # NUEVO: Callback para cargar la tabla de debug cuando cambia a la pestaña de depuración
    @app.callback(
        [Output("debug-table-container", "children"),
         Output("debug-loading-indicator", "children"),
         Output("debug-asset-selector", "options"),
         Output("debug-device-selector", "options"),
         Output("debug-data-store", "data")],
        [Input("smart-locks-tabs", "active_tab"),
         Input("smart-locks-data-store", "data")],
        [State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=[html.Div(), "", [], [], {}])
    def load_debug_table(active_tab, devices_data, token_data):
        # Si la pestaña activa no es la de debug o no hay datos, no hacer nada
        if active_tab != "debug-tab" or not devices_data:
            return html.Div(), "", [], [], {}
        
        # Obtener el token JWT
        token = token_data.get('token') if token_data else None
        if not token:
            return html.Div("No hay token JWT disponible", className="alert alert-danger"), "", [], [], {}
        
        try:
            # Inicializar el almacén de datos para depuración
            debug_store = {
                "devices": {},
                "assets": {},
                "nfc_sensors_by_device": {},
                "api_responses": {}
            }
            
            # Crear un diccionario para mapear devices a assets
            device_to_asset = {}
            asset_options = []
            device_options = []
            
            # Recopilar todos los assets únicos
            unique_assets = set()
            for device in devices_data:
                device_id = device.get("device_id", "")
                if not device_id:
                    continue
                
                asset_id = device.get("asset_id", "")
                asset_name = device.get("asset_name", "Desconocido")
                
                if asset_id:
                    unique_assets.add((asset_id, asset_name))
                    device_to_asset[device_id] = asset_id
                    debug_store["devices"][device_id] = {
                        "device_id": device_id,
                        "device_name": device.get("device_name", "Sin nombre"),
                        "lock_name": device.get("lock_name", "Sin nombre"),
                        "asset_id": asset_id,
                        "asset_name": asset_name,
                        "sensors": device.get("sensors", []),
                        "nfc_sensors": []
                    }
            
            # Convertir assets únicos en opciones para el dropdown
            for asset_id, asset_name in sorted(unique_assets, key=lambda x: x[1]):
                asset_options.append({"label": f"{asset_name} ({asset_id})", "value": asset_id})
                debug_store["assets"][asset_id] = {
                    "asset_id": asset_id,
                    "asset_name": asset_name,
                    "devices": [],
                    "api_data": {}
                }
            
            # Mapear dispositivos a sus assets y extraer información de sensores NFC
            for device in devices_data:
                device_id = device.get("device_id", "")
                asset_id = device.get("asset_id", "")
                
                if device_id and asset_id and asset_id in debug_store["assets"]:
                    device_options.append({
                        "label": f"{device.get('lock_name', 'Sin nombre')} ({device_id})",
                        "value": device_id
                    })
                    
                    # Añadir el dispositivo a la lista del asset
                    debug_store["assets"][asset_id]["devices"].append(device_id)
                    
                    # Recopilar todos los sensores NFC
                    nfc_sensors = []
                    for sensor in device.get("sensors", []):
                        if sensor and sensor.get("sensor_type") == "NFC_CODE":
                            sensor_id = sensor.get("sensor_id", "")
                            if sensor_id:
                                nfc_sensors.append({
                                    "sensor_id": sensor_id,
                                    "name": sensor.get("name", f"Sensor {sensor_id}"),
                                    "password": sensor.get("password", ""),
                                    "sensor_type": "NFC_CODE"
                                })
                    
                    debug_store["nfc_sensors_by_device"][device_id] = nfc_sensors
                    debug_store["devices"][device_id]["nfc_sensors"] = nfc_sensors
            
            # Consultar los datos NFC para cada asset
            asset_nfc_data = {}
            from utils.api import get_nfc_passwords, fetch_nfc_passwords_for_asset
            
            for asset_id in debug_store["assets"].keys():
                try:
                    # Llamar a la API para obtener los códigos NFC
                    data = fetch_nfc_passwords_for_asset(asset_id, token)
                    if data and isinstance(data, tuple) and len(data) == 2:
                        # Obtener solo los datos de la respuesta
                        response_asset_id, response_data = data
                        asset_nfc_data[asset_id] = response_data
                        debug_store["api_responses"][asset_id] = response_data
                        debug_store["assets"][asset_id]["api_data"] = response_data
                        logger.info(f"Datos NFC obtenidos para asset {asset_id}")
                    else:
                        logger.warning(f"No se pudieron obtener datos NFC para asset {asset_id}")
                except Exception as e:
                    logger.error(f"Error al obtener datos NFC para asset {asset_id}: {str(e)}")
            
            # Crear tabla con columnas dinámicas según sensores encontrados
            # Esta es la tabla principal que mostrará todas las cerraduras y sus sensores NFC
            
            # Determinar todas las columnas de sensores NFC necesarias
            all_sensor_ids = set()
            for device_data in debug_store["devices"].values():
                for sensor in device_data["nfc_sensors"]:
                    sensor_id = sensor.get("sensor_id", "")
                    if sensor_id:
                        all_sensor_ids.add(sensor_id)
            
            # Si no hay sensores NFC explícitos, buscar todos los posibles sensores NFC en los datos de la API
            if not all_sensor_ids:
                for asset_data in asset_nfc_data.values():
                    if not asset_data:
                        continue
                    
                    # Extraer sensor_ids de los datos de la API
                    try:
                        if isinstance(asset_data, dict) and "data" in asset_data:
                            data_section = asset_data["data"]
                            
                            if isinstance(data_section, list):
                                # Recorrer dispositivos
                                for device in data_section:
                                    if not isinstance(device, dict):
                                        continue
                                    
                                    # Buscar sensor_passwords
                                    sensor_passwords = device.get("sensor_passwords", [])
                                    if not isinstance(sensor_passwords, list):
                                        continue
                                    
                                    for sensor_pw in sensor_passwords:
                                        if not isinstance(sensor_pw, dict):
                                            continue
                                        
                                        sensor_id = str(sensor_pw.get("sensor_id", ""))
                                        if sensor_id:
                                            all_sensor_ids.add(sensor_id)
                                            logger.debug(f"Sensor NFC encontrado en API: {sensor_id}")
                    except Exception as e:
                        logger.error(f"Error al procesar datos de la API para buscar sensores: {str(e)}")
            
            # Asegurarse de que los sensores importantes estén en la lista
            important_sensors = ["2", "3", "4", "5", "6"]
            for sensor_id in important_sensors:
                all_sensor_ids.add(sensor_id)
            
            # Convertir a lista ordenada
            sensor_column_ids = sorted(all_sensor_ids, key=lambda x: int(x) if x.isdigit() else 999)
            
            # Definir columnas básicas para la tabla
            columns = [
                {"name": "ID", "id": "device_id"},
                {"name": "Nombre", "id": "lock_name"},
                {"name": "Asset", "id": "asset_id"},
                {"name": "Espacio", "id": "asset_name"}
            ]
            
            # Añadir columnas para cada sensor NFC
            for sensor_id in sensor_column_ids:
                columns.append({
                    "name": f"Sensor {sensor_id}",
                    "id": f"sensor_{sensor_id}"
                })
            
            # Preparar los datos para la tabla
            rows = []
            for device_id, device_data in debug_store["devices"].items():
                row = {
                    "device_id": device_id,
                    "lock_name": device_data["lock_name"],
                    "asset_id": device_data["asset_id"],
                    "asset_name": device_data["asset_name"]
                }
                
                # Añadir valores de los sensores NFC si existen
                for sensor in device_data["nfc_sensors"]:
                    sensor_id = sensor.get("sensor_id", "")
                    if sensor_id:
                        row[f"sensor_{sensor_id}"] = sensor.get("password", "N/A")
                
                # Buscar en los datos de la API valores para los sensores que no estén en los sensores explícitos
                asset_id = device_data["asset_id"]
                if asset_id in asset_nfc_data and asset_nfc_data[asset_id]:
                    api_data = asset_nfc_data[asset_id]
                    
                    # Buscar el dispositivo en los datos de la API
                    try:
                        from components.smart_locks.nfc_grid.nfc_display_grid import format_nfc_value
                        
                        if isinstance(api_data, dict) and "data" in api_data:
                            data_section = api_data["data"]
                            
                            if isinstance(data_section, list):
                                # Recorrer dispositivos
                                for device in data_section:
                                    if not isinstance(device, dict):
                                        continue
                                    
                                    api_device_id = str(device.get("device_id", ""))
                                    if api_device_id != device_id:
                                        continue
                                    
                                    # Encontrado el dispositivo, buscar sensor_passwords
                                    sensor_passwords = device.get("sensor_passwords", [])
                                    if not isinstance(sensor_passwords, list):
                                        continue
                                    
                                    # Crear un diccionario para almacenar los valores de los sensores
                                    sensor_values = {}
                                    
                                    for sensor_pw in sensor_passwords:
                                        if not isinstance(sensor_pw, dict):
                                            continue
                                        
                                        sensor_id = str(sensor_pw.get("sensor_id", ""))
                                        password = sensor_pw.get("password", "")
                                        
                                        if sensor_id and password:
                                            # Formatear el valor para que sea más legible
                                            formatted_password = format_nfc_value(password)
                                            sensor_values[sensor_id] = formatted_password
                                            logger.debug(f"Valor de API para {device_id}, sensor {sensor_id}: {formatted_password}")
                                    
                                    # Añadir los valores de los sensores a la fila
                                    for sensor_id, value in sensor_values.items():
                                        column_id = f"sensor_{sensor_id}"
                                        # Solo establecer el valor si no existe en la fila o si está vacío
                                        if column_id not in row or not row[column_id] or row[column_id] == "N/A":
                                            row[column_id] = value
                    except Exception as e:
                        logger.error(f"Error al procesar datos de API para el dispositivo {device_id}: {str(e)}")
                
                # Añadir la fila a las filas de la tabla
                rows.append(row)
            
            # Asegurar que todas las columnas necesarias estén definidas en cada fila
            for row in rows:
                for col in columns:
                    if col["id"] not in row:
                        row[col["id"]] = "N/A"
            
            # Crear la tabla
            from dash import dash_table
            
            table = dash_table.DataTable(
                id="debug-nfc-table",
                columns=columns,
                data=rows,
                style_table={
                    'overflowX': 'auto',
                    'maxHeight': '600px',
                    'overflowY': 'auto'
                },
                style_header={
                    'backgroundColor': 'rgb(230, 230, 230)',
                    'fontWeight': 'bold',
                    'textAlign': 'center'
                },
                style_cell={
                    'textAlign': 'left',
                    'padding': '5px',
                    'whiteSpace': 'normal',
                    'height': 'auto',
                    'minWidth': '100px'
                },
                style_data_conditional=[
                    {
                        'if': {'row_index': 'odd'},
                        'backgroundColor': 'rgb(248, 248, 248)'
                    },
                    {
                        'if': {'column_id': 'device_id'},
                        'fontFamily': 'monospace',
                        'width': '200px',
                        'maxWidth': '200px',
                        'overflow': 'hidden',
                        'textOverflow': 'ellipsis'
                    },
                    {
                        'if': {'column_id': 'asset_id'},
                        'fontFamily': 'monospace',
                        'width': '150px',
                        'maxWidth': '150px',
                        'overflow': 'hidden',
                        'textOverflow': 'ellipsis'
                    }
                ] + [
                    {
                        'if': {
                            'column_id': col["id"],
                            'filter_query': f'{{{col["id"]}}} ne "N/A" && {{{col["id"]}}} ne ""'
                        },
                        'backgroundColor': '#d4edda',
                        'color': '#155724'
                    } for col in columns if col["id"].startswith("sensor_")
                ],
                filter_action="native",
                sort_action="native",
                sort_mode="multi",
                export_format="csv",
                export_headers="display",
                page_size=20
            )
            
            # Estadísticas sobre los datos
            stats = html.Div([
                html.Div(f"Total de Cerraduras: {len(rows)}", className="badge bg-primary me-2"),
                html.Div(f"Total de Assets: {len(unique_assets)}", className="badge bg-secondary me-2"),
                html.Div(f"Total de Sensores NFC: {len(sensor_column_ids)}", className="badge bg-info me-2"),
                html.Div([
                    html.I(className="fas fa-info-circle me-1"),
                    "Puede hacer clic en los encabezados para ordenar y filtrar los datos."
                ], className="text-muted mt-2 small")
            ], className="mb-3")
            
            # Componente completo con estadísticas y tabla
            debug_table_container = html.Div([
                stats,
                table
            ])
            
            # Actualizar las opciones para los selectores de asset y dispositivo
            asset_options.sort(key=lambda x: x["label"])
            device_options.sort(key=lambda x: x["label"])
            
            return debug_table_container, "", asset_options, device_options, debug_store
        
        except Exception as e:
            logger.error(f"Error al cargar la tabla de debug: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return html.Div(f"Error al cargar datos de depuración: {str(e)}", className="alert alert-danger"), "", [], [], {}
    
    # NUEVO: Callback para mostrar datos de API de un asset específico
    @app.callback(
        Output("debug-api-results", "children"),
        [Input("debug-query-asset-button", "n_clicks")],
        [State("debug-asset-selector", "value"),
         State("debug-data-store", "data"),
         State("jwt-token-store", "data")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=html.Div("Seleccione un asset y haga clic en Consultar", className="text-muted"))
    def show_asset_api_data(n_clicks, asset_id, debug_data, token_data):
        if not n_clicks or not asset_id:
            return html.Div("Seleccione un asset y haga clic en Consultar", className="text-muted")
        
        # Obtener el token JWT
        token = token_data.get('token') if token_data else None
        if not token:
            return html.Div("No hay token JWT disponible", className="alert alert-danger")
        
        try:
            # Verificar si ya tenemos datos para este asset en el store
            if debug_data and "api_responses" in debug_data and asset_id in debug_data["api_responses"]:
                api_data = debug_data["api_responses"][asset_id]
            else:
                # Si no tenemos datos, consultar a la API
                from utils.api import fetch_nfc_passwords_for_asset
                result = fetch_nfc_passwords_for_asset(asset_id, token)
                api_data = result[1] if result and isinstance(result, tuple) and len(result) == 2 else None
            
            if not api_data:
                return html.Div("No se encontraron datos en la API para este asset", className="alert alert-warning")
            
            # Crear estructura más legible de los datos
            api_results = []
            
            # Extraer información de dispositivos y sensores
            if isinstance(api_data, dict) and "data" in api_data:
                data_section = api_data["data"]
                
                if isinstance(data_section, list):
                    # Procesar cada dispositivo
                    for device in data_section:
                        if not isinstance(device, dict):
                            continue
                        
                        device_id = device.get("device_id", "Desconocido")
                        
                        # Crear tarjeta para el dispositivo
                        device_card = html.Div([
                            html.H6(f"Dispositivo: {device_id}", className="card-title"),
                            
                            # Verificar si tiene sensor_passwords
                            html.Div([
                                # Crear tabla para los sensores
                                html.Table([
                                    html.Thead([
                                        html.Tr([
                                            html.Th("Sensor ID"),
                                            html.Th("Nombre"),
                                            html.Th("Valor")
                                        ])
                                    ]),
                                    html.Tbody([
                                        html.Tr([
                                            html.Td(sensor.get("sensor_id", "")),
                                            html.Td(sensor.get("name", f"Sensor {sensor.get('sensor_id', '')}")),
                                            html.Td(sensor.get("password", ""))
                                        ]) for sensor in device.get("sensor_passwords", []) if isinstance(sensor, dict)
                                    ])
                                ], className="table table-sm table-bordered") if device.get("sensor_passwords") else html.P("No hay sensores para este dispositivo")
                            ])
                        ], className="card mb-3 p-3")
                        
                        api_results.append(device_card)
                elif isinstance(data_section, dict):
                    # Formato alternativo - mapeo de sensor_id a dispositivos
                    for sensor_id, sensor_data in data_section.items():
                        if not isinstance(sensor_data, dict):
                            continue
                        
                        # Crear tarjeta para el sensor
                        sensor_card = html.Div([
                            html.H6(f"Sensor: {sensor_id}", className="card-title"),
                            
                            # Crear tabla para los dispositivos
                            html.Table([
                                html.Thead([
                                    html.Tr([
                                        html.Th("Dispositivo ID"),
                                        html.Th("Valor")
                                    ])
                                ]),
                                html.Tbody([
                                    html.Tr([
                                        html.Td(device_id),
                                        html.Td(password)
                                    ]) for device_id, password in sensor_data.items() if device_id and password
                                ])
                            ], className="table table-sm table-bordered")
                        ], className="card mb-3 p-3")
                        
                        api_results.append(sensor_card)
            
            # Si no se pudo procesar en el formato esperado, mostrar el JSON en bruto
            if not api_results:
                import json
                api_results = [
                    html.Div("Formato de datos no reconocido. JSON en bruto:", className="alert alert-warning"),
                    html.Pre(json.dumps(api_data, indent=2), className="bg-light p-3 border rounded", style={"maxHeight": "400px", "overflow": "auto"})
                ]
            
            # Componente completo con resultados de la API
            return html.Div([
                html.H6(f"Datos API para Asset: {asset_id}", className="mb-3"),
                html.Div(api_results)
            ])
        
        except Exception as e:
            logger.error(f"Error al mostrar datos de API para asset {asset_id}: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return html.Div(f"Error al consultar datos de API: {str(e)}", className="alert alert-danger")
    
    # NUEVO: Callback para comparar datos de un dispositivo específico
    @app.callback(
        Output("debug-comparison-results", "children"),
        [Input("debug-compare-device-button", "n_clicks")],
        [State("debug-device-selector", "value"),
         State("debug-data-store", "data"),
         State("nfc-grid-table", "data"),
         State("nfc-grid-table", "columns")],
        prevent_initial_call=True
    )
    @handle_exceptions(default_return=html.Div("Seleccione un dispositivo y haga clic en Comparar", className="text-muted"))
    def compare_device_data(n_clicks, device_id, debug_data, grid_data, grid_columns):
        if not n_clicks or not device_id:
            return html.Div("Seleccione un dispositivo y haga clic en Comparar", className="text-muted")
        
        try:
            if not debug_data or not "devices" in debug_data or not device_id in debug_data["devices"]:
                return html.Div("No se encontraron datos de debug para este dispositivo", className="alert alert-warning")
            
            # Datos del dispositivo en la tabla de debug
            device_debug_data = debug_data["devices"][device_id]
            asset_id = device_debug_data["asset_id"]
            
            # Buscar el dispositivo en el grid de NFC para comparar
            grid_device_data = None
            if grid_data and isinstance(grid_data, list):
                for row in grid_data:
                    if row.get("device_id") == device_id:
                        grid_device_data = row
                        break
            
            # Extraer sensor_ids de las columnas del grid
            sensor_columns = []
            if grid_columns and isinstance(grid_columns, list):
                sensor_columns = [col for col in grid_columns if col["id"].startswith("sensor_")]
            
            # Datos de la API
            api_data = None
            if "api_responses" in debug_data and asset_id in debug_data["api_responses"]:
                api_data = debug_data["api_responses"][asset_id]
                
                # Procesar datos de la API para extraer información del dispositivo
                api_device_data = {}
                
                if isinstance(api_data, dict) and "data" in api_data:
                    data_section = api_data["data"]
                    
                    if isinstance(data_section, list):
                        # Buscar el dispositivo en la lista
                        for device in data_section:
                            if not isinstance(device, dict):
                                continue
                            
                            api_device_id = str(device.get("device_id", ""))
                            if api_device_id == device_id:
                                # Extraer sensores
                                sensor_passwords = []
                                if "sensor_passwords" in device and isinstance(device["sensor_passwords"], list):
                                    for sensor in device["sensor_passwords"]:
                                        if not isinstance(sensor, dict):
                                            continue
                                        
                                        sensor_id = str(sensor.get("sensor_id", ""))
                                        password = sensor.get("password", "")
                                        
                                        if sensor_id:
                                            sensor_passwords.append({
                                                "sensor_id": sensor_id,
                                                "password": password
                                            })
                                
                                api_device_data = {
                                    "device_id": api_device_id,
                                    "sensor_passwords": sensor_passwords
                                }
                                break
            
            # Crear componentes para la comparación
            comparison = []
            
            # Información básica del dispositivo
            device_info = html.Div([
                html.H6("Información del Dispositivo", className="mb-3"),
                html.Div([
                    html.Strong("ID: "),
                    html.Span(device_id, className="font-monospace")
                ], className="mb-2"),
                html.Div([
                    html.Strong("Nombre: "),
                    html.Span(device_debug_data["lock_name"])
                ], className="mb-2"),
                html.Div([
                    html.Strong("Asset: "),
                    html.Span(f"{device_debug_data['asset_name']} ({asset_id})")
                ], className="mb-2")
            ], className="card p-3 mb-3")
            
            comparison.append(device_info)
            
            # SECCIÓN 1: Sensores de la API
            api_section = html.Div([
                html.H6("Datos de la API", className="mb-3"),
                
                html.Div(
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("Sensor ID"),
                                html.Th("Valor")
                            ])
                        ]),
                        html.Tbody([
                            html.Tr([
                                html.Td(sensor["sensor_id"]),
                                html.Td(sensor["password"] or "Vacío")
                            ]) for sensor in api_device_data.get("sensor_passwords", [])
                        ])
                    ], className="table table-sm table-bordered") if api_device_data and api_device_data.get("sensor_passwords") 
                    else html.Div("No se encontraron datos en la API para este dispositivo", className="alert alert-warning")
                )
            ], className="card p-3 mb-3")
            
            comparison.append(api_section)
            
            # SECCIÓN 2: Sensores en la Matriz NFC
            grid_section = html.Div([
                html.H6("Datos en la Matriz NFC", className="mb-3"),
                
                html.Div(
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("Sensor ID"),
                                html.Th("Valor")
                            ])
                        ]),
                        html.Tbody([
                            html.Tr([
                                html.Td(col["id"].replace("sensor_", "")),
                                html.Td(grid_device_data.get(col["id"], "N/A"))
                            ]) for col in sensor_columns if grid_device_data and col["id"] in grid_device_data
                        ])
                    ], className="table table-sm table-bordered") if grid_device_data and sensor_columns
                    else html.Div("No se encontraron datos en la Matriz NFC para este dispositivo", className="alert alert-warning")
                )
            ], className="card p-3 mb-3")
            
            comparison.append(grid_section)
            
            # SECCIÓN 3: Discrepancias encontradas
            discrepancies = []
            
            # Comparar datos de la API con la matriz NFC
            if api_device_data and api_device_data.get("sensor_passwords") and grid_device_data and sensor_columns:
                # Crear un mapa de sensores de la API
                api_sensors = {sensor["sensor_id"]: sensor["password"] for sensor in api_device_data["sensor_passwords"]}
                
                # Verificar cada sensor en la matriz
                for col in sensor_columns:
                    sensor_id = col["id"].replace("sensor_", "")
                    grid_value = grid_device_data.get(col["id"], "N/A")
                    
                    # Verificar si el sensor está en la API
                    if sensor_id in api_sensors:
                        api_value = api_sensors[sensor_id]
                        
                        # Comprobar si hay discrepancia
                        if (grid_value == "N/A" or not grid_value) and api_value:
                            discrepancies.append({
                                "sensor_id": sensor_id,
                                "issue": "Valor en API pero no en matriz",
                                "api_value": api_value,
                                "grid_value": grid_value
                            })
                        elif grid_value and grid_value != "N/A" and api_value != grid_value:
                            discrepancies.append({
                                "sensor_id": sensor_id,
                                "issue": "Valores diferentes",
                                "api_value": api_value,
                                "grid_value": grid_value
                            })
                    elif grid_value and grid_value != "N/A":
                        discrepancies.append({
                            "sensor_id": sensor_id,
                            "issue": "Valor en matriz pero no en API",
                            "api_value": "No disponible",
                            "grid_value": grid_value
                        })
                
                # Verificar sensores en la API pero no en la matriz
                for sensor_id, api_value in api_sensors.items():
                    grid_col = f"sensor_{sensor_id}"
                    if grid_col not in grid_device_data and api_value:
                        discrepancies.append({
                            "sensor_id": sensor_id,
                            "issue": "Sensor en API pero no en matriz",
                            "api_value": api_value,
                            "grid_value": "No existe columna"
                        })
            
            # Mostrar discrepancias
            discrepancies_section = html.Div([
                html.H6("Discrepancias Encontradas", className="mb-3"),
                
                html.Div(
                    html.Table([
                        html.Thead([
                            html.Tr([
                                html.Th("Sensor ID"),
                                html.Th("Problema"),
                                html.Th("Valor API"),
                                html.Th("Valor Matriz")
                            ])
                        ]),
                        html.Tbody([
                            html.Tr([
                                html.Td(discrepancy["sensor_id"]),
                                html.Td(discrepancy["issue"]),
                                html.Td(discrepancy["api_value"]),
                                html.Td(discrepancy["grid_value"])
                            ]) for discrepancy in discrepancies
                        ])
                    ], className="table table-sm table-bordered table-danger") if discrepancies
                    else html.Div("No se encontraron discrepancias", className="alert alert-success")
                )
            ], className="card p-3 mb-3")
            
            comparison.append(discrepancies_section)
            
            return html.Div(comparison)
        
        except Exception as e:
            logger.error(f"Error al comparar datos del dispositivo {device_id}: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return html.Div(f"Error al comparar datos: {str(e)}", className="alert alert-danger")